---
title: "Supporting Information: The Regional Effects of Marine Protected Areas"
author:  Daniel Ovando,Jennifer E. Caselle,Christopher Costello,Olivier Deschenes,Steven D. Gaines,Ray Hilborn,Owen Liu
output: 
  bookdown::pdf_document2:
    keep_tex: true
  pdf_document: default
bibliography: My Library.bib
header-includes:
    - \usepackage{longtable}
    - \usepackage{booktabs}
    - \usepackage{eso-pic}
    - \usepackage{graphicx}
    - \usepackage[left]{lineno}
    - \linenumbers
params:
  run_name: ["v5.0"]
  sim_years: [50]
  burn_years: [20]
  num_patches: [25]
always_allow_html: true
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE)

library(sf)
library(ggmap)
library(viridis)
library(hrbrthemes)
library(scales)
library(patchwork)
library(rpart)
library(extrafont)
library(caret)
library(ggsci)
library(rEDM)
library(tidyverse)
library(Synth)
library(spasm)
extrafont::loadfonts()
functions <- list.files(here::here("functions"))

walk(functions, ~ here::here("functions", .x) %>% source()) # load local functions
save_plots <- TRUE

# sim_years <- 50
# 
# burn_years <- 20
# 
# num_patches <- 25
# 
# run_name <- "v5.0"

run_name <- params$run_name

sim_years <- params$sim_years

burn_years <- params$burn_years

num_patches <- params$num_patches

run_dir <- here::here("results", run_name)

experiment_dir <- here::here("results",run_name, "experiments")

load(file = here::here("results",run_name, "rawish_zissou_data.Rdata"))

load(file = here::here("results",run_name, "model_runs.Rdata"))

load(file = here::here("results",run_name,"processed_grid.Rdata"))

load(file.path(run_dir,"abundance_data.Rdata"))

density_ratios <- readRDS(file.path(run_dir,"density_ratios.rds"))

outcomes <- readRDS(file.path(run_dir,"outcomes.rds"))


   eqo <- outcomes %>%
     filter(year == max(year))

facet_labels <- c(
  mpa_size = "Range in MPA",
  depletion = "Without-MPA Depletion"
)

channel_islands <- readRDS(here::here("data","channel_islands_map.RDS"))

ca_mpas <- sf::st_read(here::here("data","MPA_CA_Existing_160301")) %>%
  rmapshaper::ms_simplify() %>%
  sf::st_transform(crs = 4326)



zissou_theme <-
  theme_ipsum(
    base_size = 12,
    axis_title_size = 12,
    strip_text_size = 12,
    base_family = "Helvetica"
  )

zissou_theme <- zissou_theme +
  theme(   panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank())


testplot <- ggplot()

panel_height = unit(1,"npc") - sum(ggplotGrob(testplot)[["heights"]][-3]) - unit(4,"line")

gc <- guide_colorbar(frame.colour = "black",
                     ticks.colour = "white",
                     barheight = panel_height)


  hgc <- guide_colorbar(frame.colour = "black",
                       ticks.colour = "black",
                       barwidth = 10)

  
    wide_hgc <- guide_colorbar(frame.colour = "black",
                       ticks.colour = "black",
                       barwidth = 25)
    
theme_set(zissou_theme)


models_worked <- model_runs$tmb_fit %>% map("error") %>% map_lgl(is_null)

model_runs <- model_runs %>%
  filter(models_worked) %>%
  mutate(tmb_fit = map(tmb_fit,"result")) %>%
  mutate(processed_fits = map(tmb_fit, process_fits)) %>%
  mutate(did_plot = map(processed_fits, "did_plot"))

base_run <- model_runs %>%
filter(var_names == "pisco_a", mpa_only == FALSE, center_scale == TRUE)

mpa_run <- model_runs %>%
  filter(data_source == "pisco",
         var_names == "pisco_a",
         mpa_only == TRUE)

kfm_run <- model_runs %>%
  filter(data_source == "kfm")

fitted_data <- base_run$data[[1]]

zissou_fit <- base_run$tmb_fit[[1]]

report <- base_run$tmb_fit[[1]]

site_data <- read_csv(here::here("data",'Final_Site_Table_UCSB.csv')) %>%
  magrittr::set_colnames(., tolower(colnames(.))) %>%
  select(
    site,
    side,
    mpagroup,
    mpa_status,
    reserve,
    region,
    year_mpa,
    mpaareanm2,
    lat_wgs84,
    lon_wgs84
  ) %>%
  rename(lat_wgs84 = lon_wgs84,
         lon_wgs84 = lat_wgs84) %>%
  unique() %>%
  mutate(eventual_mpa = (year_mpa > 0))

zissou_fit$zissou_estimates <- zissou_fit$zissou_estimates %>%
  mutate(variable = str_replace_all(variable, "(\\.).*$",""))

report$zissou_estimates <- report$zissou_estimates %>% 
    mutate(variable = str_replace_all(variable, "(\\.).*$",""))


seen_non_nested_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "seen_non_nested_betas")) %>%
  rename(group = variable) %>%
  mutate(variable  = zissou_fit$zissou_data$x_seen_non_nested %>% colnames())

seeing_non_nested_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "seeing_non_nested_betas")) %>%
  rename(group = variable) %>%
  mutate(variable  = zissou_fit$zissou_data$x_seen_non_nested %>% colnames())

seen_year_species_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "seen_year_species_betas")) %>%
  rename(group = variable) %>%
  mutate(variable = zissou_fit$zissou_data$x_seen_year_species %>% colnames())

seeing_year_species_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "seeing_year_species_betas")) %>%
  # filter(variable == "seeing_year_species_betas") %>%
  rename(group = variable) %>%
  mutate(variable = zissou_fit$zissou_data$x_seen_year_species %>% colnames())

seen_region_cluster_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "seen_region_cluster_betas")) %>%
  # filter(variable == "seen_region_cluster_betas") %>%
  rename(group = variable) %>%
  mutate(variable = zissou_fit$zissou_data$x_seen_region_cluster %>% colnames())

seeing_region_cluster_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "seeing_region_cluster_betas")) %>%
  # filter(variable == "seeing_region_cluster_betas") %>%
  rename(group = variable) %>%
  mutate(variable = zissou_fit$zissou_data$x_seen_region_cluster %>% colnames())

did_betas <- zissou_fit$zissou_estimates %>%
  filter(stringr::str_detect(variable, "mpa_effect")) %>%
  # filter(variable == "mpa_effect") %>%
  mutate(group = variable) %>%
  mutate(year = zissou_fit$did_data$year %>% unique())


 betas <- bind_rows(
   seen_non_nested_betas,
   seeing_non_nested_betas,
   seen_year_species_betas,
   seeing_year_species_betas,
   seen_region_cluster_betas,
   seeing_region_cluster_betas,
   did_betas %>% select(-year)
 ) %>%
   as_data_frame()

 non_nested_beta_plot <- betas %>%
   filter(str_detect(group, "non_nested")) %>%
   ggplot() +
   geom_hline(aes(yintercept = 0), linetype = 2, color = "red") +
   geom_pointrange(aes(x = variable,
                       y = estimate,
                       ymin = lower,
                       ymax = upper)) +
   facet_wrap(~group) +
   coord_flip() +
   theme(axis.text.y = element_text(size = 10))


 year_species_effects_plots <- betas %>%
   filter(str_detect(group, "year_species_betas")) %>%
   mutate(year = str_replace_all(variable,"\\D","") %>% as.numeric()) %>%
   mutate(classcode = str_split(variable,'-', simplify = T)[,2]) %>%
   ggplot() +
   geom_hline(aes(yintercept = 0), linetype = 2, color = "red") +
   geom_ribbon(aes(x = year, ymin = lower, ymax = upper, fill = classcode), alpha = 0.25) +
   geom_line(aes(x = year, y = estimate, color = classcode)) +
   facet_wrap(~group)

  region_cluster_plots <- betas %>%
   filter(str_detect(group, "region_cluster_betas")) %>%
   mutate(cluster = str_replace_all(variable,"\\D","")) %>%
   mutate(region = str_split(variable,'-', simplify = T)[,3]) %>%
   ggplot() +
    geom_hline(aes(yintercept = 0), linetype = 2, color = "red") +
    geom_pointrange(aes(x = region,
                        y = estimate,
                        ymin = lower,
                        ymax = upper, color = cluster)) +
    facet_wrap(~group)




  sim_plot <- outcomes %>%
    mutate(rsize = plyr::round_any(mpa_size, 0.25),
           reff = plyr::round_any(mpa_effect,0.1)) %>%
    filter(rsize == 0.25) %>%
    mutate(year = years_protected + 2001) %>%
    filter(year %in% did_betas$year) %>% 
    group_by(year, reff) %>% 
    count() %>% 
    group_by(year) %>% 
    mutate(sc = n / sum(n))

  did_plot <- did_betas %>%
    ggplot() +
    geom_tile(data = sim_plot, aes(year, reff, fill = sc), alpha = 0.75) +
    geom_vline(aes(xintercept = 2003), color = 'red', linetype = 2, size = 2) +
    geom_hline(aes(yintercept = 0)) +
    geom_pointrange(aes(
      year,
      y = exp(estimate) - 1,
      ymin = exp(lower) - 1,
      ymax = exp(upper) - 1
    ),
    size = 1.5
    ) +
    labs(x = "Year", y = "Targeted Trend Divergence") +
    scale_fill_viridis(guide = hgc,
                       name = "% of Annual Sims",
                       labels = scales::percent_format(accuracy = 1),
                       option = "plasma") + 
    theme(legend.position = "top")
  
top_species <- base_run$data[[1]]$classcode %>% unique()

cip_data <- pisco_data %>%
  left_join(site_data, by = c("site","side")) %>%
  filter(is.na(eventual_mpa) == F) %>%
  filter(region %in% c("ANA", "SCI","SRI",'SMI'),
         classcode %in% top_species)

# process outcomes

filter_summary <- fitted_data %>% 
  select(classcode, targeted) %>% 
  unique() %>% 
  group_by(targeted) %>% 
  count() %>% 
  ungroup() %>% 
  mutate(targeted = ifelse(targeted == 1,"yes","no")) %>% 
  spread(targeted, n)

```


# Supporting Information (SI) 

# SI Text {#si-text .unnumbered}

## Computing environment

The computing environment needed to reproduce the results presented here is stored in a Docker container available [here]()XX. Interested users can load the container on their system to reproduce the complete analysis and manuscript. Analysis were performed in `r R.version.string`. Package versions are shown in Table.S\@ref(tab:pkg-info).

```{r pkg-info, results = "asis"}
table <- devtools::package_info() %>% 
  select(package, loadedversion, date,source)

knitr::kable(table,
             digits = 2,
             caption = "Package versions and sources used in this paper",
             longtable = TRUE,
             booktabs = TRUE,
             format = "latex",
             col.names = colnames(table)) %>% 
  kableExtra::kable_styling(latex_options = c("hold_position", "repeat_header"))

```



## Operating Model

The operating model is a spatial single-species age-structured bio-economic model. The operating model itself is organized as an R package, which can be found and installed [here](https://github.com/DanOvando/spasm). Users can explore the functionality of the operating mode through an interactive web application [here](https://danovando.shinyapps.io/simmpa/). 


For the population model, numbers *n* at time *t* for age *a* are given by 

\begin{equation}
n_{t,a}=\begin{cases}
      = BH(ssb_{t-1}) & \text{if $a = 1$}\\
     = n_{t-1,a-1}e^{-(m + qE_{t-1}{\times}s_{a-1})}, & \text{if $1< a < max(age)$}\\
     =  n_{t-1,a}e^{-(m + qE_{t-1}{\times}s_a)} + n_{t-1,a-1}e^{-(m + qE_{t-1}{\times}s_{a-1})}, & \text{if $a = max(a)$}
  \end{cases}
  (\#eq:pop)
\end{equation}

where *BH* is the Beverton-Holt recruitment function, *ssb* is spawning-stock-biomass, *m* is natural mortality, *q* is catchability,*E* is fishing effort at time *t*, and *s* is selectivity at age *a*. 

Selectivity is modeled through a logistic form per

\begin{equation}
s_a=\frac{1}{(1 + e^{-log(19)\times\frac{l_a - l_{sel}}{\delta_{sel}}})}
  (\#eq:sel)
\end{equation}

where $l_a$ is the mean length at at age, $l_sel$ is the length at which on average 50\% of individuals are selected by the fishery, and $\delta_{sel}$ are the additional units of length at which on average 95\% of fish are selected by the fishery. 

*ssb* is calculated by converting age to mean length, calculating weight at age, maturity at age, and then calculating spawning stock biomass as the sum of spawning potential at age in a given time step. 

\begin{equation}
  l_{a} = l_{\infty}\left(1 - e^{-k(a - a_0)}\right)
  (\#eq:len)
\end{equation}



Weight at age is then given by 

\begin{equation}
  b_{a} = w_a \times l_{a}^{w_b}
  (\#eq:weight)
\end{equation}


and maturity *mat* is calculated as

\begin{equation}
  \frac{1}{(1 + e^{-log(19)\times\frac{l_a - l_{mat}}{\delta_{mat}}})}
  (\#eq:mat)
\end{equation}


where $l_{mat}$ is the length at which on average 50\% of individuals are sexual maturity, and $\delta_{mat}$ is the units of length beyond $l_{mat}$ at which on average 95\% of fish are sexually mature.

Spawning stock biomass at time *t* is then calculated as

\begin{equation}
  ssb_t = \sum_{a=1}^Aw_{a,t}mat_{a,t}n_{a,t}
    (\#eq:ssb)
\end{equation}


### Recruitment

Recruitment follows Beverton-Holt dynamics. We do however allow for three variants in the timing of density dependence:

  1. Local density dependence: Density dependence occurs independently in each patch, and recruits then disperse to nearby patches
  
\begin{equation}
  n_{t,a = 1,p} = \left(\frac{0.8{\times}r0_{p}\times{h}\times{ssb_{t-1,p}}}{0.2\times{ssb0_p}\times(1 - h)+(h - 0.2)\times{ssb_{t-1,p}}}\right)\times \boldsymbol{d^l} \times \epsilon_t
  (\#eq:dd1)
\end{equation}


where **d^l^** is the larval movement matrix, *h* is Beverton-Holt steepness (constrained between 0.6 and 0.99), *r0* is unfished recruitment, and *ssb0* is unfished spawning stock biomass.
  
  2. Global density dependence: Density dependence is a function of the sum of spawning biomass across all patches, and recruits are then distributed according to habitat quality

\begin{equation}
n_{t,a = 1,p} = \left(\frac{0.8{\times}\sum_{p=1}^P{r0_{p}}\times{h}\times\sum_{p=1}^P{ssb_{t-1,p}}}{0.2\times{\sum_{p=1}^Pssb0_p}\times(1 - h)+(h - 0.2)\times{\sum_{p=1}^Pssb_{t-1,p}}}\right)\times {hab_p} \times \epsilon_t
  (\#eq:dd2)
\end{equation}  
  

where *hab* is a vector of habitat quality by patch that sums to 1. 


3. Post-dispersal density dependence: Larvae are distributed throughout the system, and then density dependence occurs based on the density of adult biomass at the destination patch.


\begin{equation}
  larv_{t,p} = ssb_{t-1} \times\boldsymbol{d^l}
  (\#eq:larvmove)
\end{equation}


\begin{equation}
n_{t,a = 1,p} = \left(\frac{0.8{\times}r0_{p}\times{h}\times{larv_{t,p}}}{0.2\times{ssb0_p}\times(1 - h)+(h - 0.2)\times{larv_{t,p}}}\right) \times \epsilon_t
  (\#eq:dd3)
\end{equation}

$\epsilon$ represents multiplicative recruitment deviates. Deviates are calculated as


$$\epsilon_t = e^{recdev_t}$$  

`$recdev$ are the log-normal recruitment deviates in time *t*. 

The stochastic component of the deviate is 

$$\gamma_t \sim norm(-\sigma_r^2/2,\sigma_r)$$

and the final multiplicative recruitment deviate in time *t* is then

$$recdev_t = \gamma_t\sqrt{1 - ac_r^2} + recdev_{t-1}ac_r $$

where *ac* is the autocorrelation of the recruitment function (between 0 and 1). 

  
### Dispersal

Dispersal in the model is broken into two components: adult and larval. Both assume a Gaussian dispersal kernel of the form

\begin{equation}
m_{s,p_i,p_j}=\frac{1}{\sqrt{2\pi\sigma_{s,p_i}^2}}e^{-\frac{d_{p_i,p_j}^2}{2\sigma_{s,p_i}^2}}
  (\#eq:move)
\end{equation}


where *i* is the source patch, *j* is the destination patch, *d* is the distance between patches *i* and *j* (where distance is measured with wrapped edges, such that if there are 50 patches, patch 1 and patch 50 have a distance of 1), and $\sigma_s*$is the movement rate, in units of patches, for life stage *s* (adult or larval).

We allow the adult dispersal matrix to be affected by adult density dependence. The idea behind this is that adult fish will move more as densities increase, and become more sedentary as densities decrease (as habitat and food become more available for example). This allows us to simulate a scenario where as MPAs build up density they begin to export more adults to the surrounding waters, and if densities are lower in the fished areas these fish will actually become more sedentary. 

Under these conditions, the adult movement rate is a linear function of depletion (measured as $ssb/ssb_0$)

\begin{equation}
\sigma_{s=a,p}^* = max(slope\times{d _p+ \sigma_{s=a} \times dmod},0)
  (\#eq:ddmove1)
\end{equation}

where 

\begin{equation}
slope = \sigma_{s=a} - ( \sigma_{s=a} \times dmod)
  (\#eq:ddmove2)
\end{equation}


Under these conditions, when depletion *d = 1* (meaning the stock is unfished) the adult movement rate equals the max adult movement rate ($\sigma_{s=a}^* = \sigma_{s=a}$). When $d=0$ $\sigma_{s=a}^* = \sigma_{s=a} * dmod$. The greater *dmod* is then, the more movement rates from a patch decline as density declines.

We also allow for a "sprinkler" condition in which MPAs are placed in locations that disperse larvae to a much wider area than non-MPA locations. In this world, we simply multiply $\sigma_{s=l,p}$ by a sprinkler factor (by default 4) for any patch *p* that would eventually become an MPA (whether or not MPAs are ever introduced). In other words, when we compare two scenarios, one with MPA and one without, the "without" scenario still has higher larval movement rates in patches that become MPAs in the "with" scenario.

### Fleet Dynamics

We allow for three fleet models: constant effort, constant catch, and open-access. Constant effort means that total effort across all patches is equal in all time steps (unless MPAs force exit of effort as discussed below). Under constant catch, we set a target catch volume (in biomass, summed across all patches). Each time step, we calculate the fishing mortality rate that, given the fishable biomass in that time step, would produce the target catch. If there is insufficient fishable biomass available to support the target catch, we mark the population as crashed and stop the simulation (these crashed simulations are not included in the final analysis).

Under open-access, fishing effort expands in proportion to a weighted mean of profit-per-unit effort over the last *t* time steps.

\begin{equation}
profit_{t} = price\times{catch_t} - cost\times{E_t}^2
  (\#eq:profit)
\end{equation}


From there, we determine the new effort as 

\begin{equation}
E_t = E_{t-1} + \theta\times\sum_{i=t-1-l}^{t-1}w_i\frac{profit_{i}}{E^i}
  (\#eq:openaccess)
\end{equation}


where *w* is a weighting function which is just a linear function of time


\begin{equation}
  w_i = \frac{i}{\sum_{i=1}^li}
  (\#eq:oaweight)
\end{equation}

and *l* is the number of lagged time steps over which to calculate the weighted mean PPUE.

The open-access model can enter chaotic dynamics if the model parameters are not properly tuned. To address this, we first set price at 1, and set a $\theta$ such that when profits are about as large as they might conceivably be the fishery doubles in size. We then estimate reference points for the simulated fishery (Bmsy, Fmsy, MSY), and set a target bionomic equilibrium B/Bmsy. Holding the other parameters constant, we thing find a cost coefficient that produces the desired bionomic equilibrium. 

### Spatial Fleet Distribution

Given a total amount of effort, we then need to distribute that effort in space. In the simplest form, effort is evenly distributed throughout the available patches. 


\begin{equation}
E_{t,p} = E_t \times \frac{open_p}{\sum_{p=1}^Popen_p}
  (\#eq:simpleeffort)
\end{equation}



where *open* indicates whether patch *p* is open to fishing or not. 

Effort can also be distributed according to spawning stock biomass in fishable patches

\begin{equation}
E_{t,p} = E_t \times \frac{open_{t,p}ssb_{t,p}}{\sum_{p=1}^Popen_{t,p}ssb_{t,p}}
  (\#eq:biomasseffort)
\end{equation}


And lastly effort can be distributed according to profit-per-unit-effort


\begin{equation}
E_{t,p} = E_t \times \frac{open_{t,p}ppue_{t,p}}{\sum_{p=1}^Popen_{t,p}ppue_{t,p}}
  (\#eq:ppueeffort)
\end{equation}


Under the constant effort or open access scenarios, effort can immediately respond to MPA placement in one of two ways. Effort can concentrate outside the MPAs (such that the sum of effort before and after MPA placement stays constant), or effort can leave the MPAs, such that the total effort in the fishery is reduced by the amount of effort that occurred inside the MPAs immediately before MPA placement. This is intended to simulate a scenario where fishers that used to use the MPA simply leave the fishery rather than redistribute outside the MPA, due for example to costs or lack of location specific knowledge to fish outside the MPA.

### MPA Design

MPA design is relatively straightforward. We set a percentage of patches that are to be placed inside no-take MPAs. MPAs can either be placed continuously (e.g if there are 100 patches and 25% are in MPAs, patches 1 to 25 are in MPAs) or randomly. If the MPAs are placed randomly, we can also set a minimum MPA size. This controls the patchiness of the MPAs. As the "patchiness" factor approaches zero, the behavior equals that of random placement. As it approaches 1, the behavior approaches that of continuous placement. In between, the greater the patchiness, the more clustered together MPAs become.


## Simulations

We use this our operating model to simulate 10,000 different fisheries, where each fishery is a random combination of variables, described below

Table.S1 - Range of simulated variables

| Variable | Distribution|
|---------:|:-----------:|
| Scientific Name | Drawn from all possible species in `FishLife` (@thorson2017c)|
|steepness (h) | ~uniform(0.6,0.95)|
|Adult movement ($\sigma_{s=a}$) | ~uniform(0,0.5 * P)|
|Larval movement ($\sigma_{s=l}$) | ~uniform(0,0.5 * P)|
|Recruitment variation ($\sigma_{r}$) |  $\in\{0,0.05,.1\}$|
|Recruitment autocorrelation ($ac_{r}$) |  $\in\{0,0.05,.1\}$|
|DD adult movement (dmod) | $\in\{0.25,1\}$|
|Density-dependence timing | $\in\{local, global,post-dispersal\}$|
|\% Patches in MPA | ~uniform(0.01,1)|
|Initial fishing relative to natural mortality | ~uniform(0.01,4)|
|Selectivity as a multiple of maturity length| ~uniform(0.1,1.25)|
|Fleet model| $\in\{open-access, constant-effort,constant-catch\}$|
|Spatial effort model| $\in\{uniform, biomass,profits\}$|
|Years into simulation to start MPA| ~round(uniform(5,0.66 * T))|
|MPA is sprinkler?| $\in\{TRUE,FALSE\}$|
|Randomly place MPA?| $\in\{TRUE,FALSE\}$|
|Fleet reaction to MPA| $\in\{concentrate, abandon-ship\}$|
|Patchiness | ~uniform(0.01,0.75)|
|MPA habitat factor| $\in\{1, 4\}$|

One thing to note here is the random sampling of species' scientific names. The effect of MPAs, especially over the short term, will clearly be affected by factors such as the growth rate, the mortality rate, and the maturity schedule. These life history traits are related through a variety of biological processes, as such randomly sampling these parameters can lead to biologically nonsensical "frankenfish". We resolve this by using the `FishLife` package (@thorson2017c) instead. `FishLife` builds off of [FishBase](https://fishbase.org/), and provides estimate of key life history traits taking into account the relationships across these variables. For simulations then, we randomly pull a species from `FishLife`, and then pull the available life history information from that species for use in the operating model. This allows us to simulate a wide range of life history types in a realistic manner.

We ran 20,000 simulations from these distributions. Each simulation runs for 50 years in 50 patches (with a 25 year unfished burn-in period for conditions in which initial conditions cannot be solved analytically, for example when MPAs have better habitat than non-MPAs). For each simulation, we run one scenario without MPAs, though taking note of where the MPA would be as needed. For the second scenario, we hold everything constant except we now add in the MPAs as dictated by the particular simulation. 

##### Filtering Simulations

After the 20,000 simulations have run, we perform a series of filtering steps to remove runs that either a) produced chaotic dynamics during the open-access scenario; b) did not converge to the correct bionomic equilibrium in the open-access scenario; or c) crashed the population before the MPAs went into place (population falls below 5% of unfished biomass). These filtering steps left us with `r nrow(processed_grid) ` viable simulations. 


#### Additional Simulation Results

Simulation results are presented as percent differences in biomass densities with and without MPAs, in order to be comparable to the estimates that the regression model produces. However, this metric presents some problems as a measure of how "detectable" an effect size is. As depletion increases, relatively small changes in total biomass (relative to the variance in the observation process) can translate into large percent changes in biomass. For example, moving from a density of .2kg/m^2^ to .4kg/m^2^ translates to a 100% percent increase, but only a .2kg/m^2^ absolute increase, a small value to detect with a real observation program. 

To illustrate these, we present an alternative to our simulation results in which changes in biomass caused by MPAs is scaled by the unfished biomass in the system. 

```{r pop-conservation-effect, include = TRUE, fig.cap="Median (A) and range (B) of equilibrium regional MPA conservation effects (change in total biomass with MPAs relative to without MPAs as a percentage of unfished biomass) across a range of depletion and MPA sizes (and incorporating the full range of scenarios included in our study). 'Range in MPA' is the percent of patches covered by an MPA, 'Depletion' is the depletion that would have occurred in equilibrium without the MPA"}


pop_time_plot <- outcomes %>%
  filter(years_protected > 0) %>%
  ggplot(aes(years_protected, pop_effect)) +
  geom_bin2d() +
  scale_fill_viridis(guide = gc)

ylabs <- c(expression(""<= "-50%"), paste0(seq(-25,75, by = 25),"%"),expression("">= "100%") )


ybreaks = seq(-.50,1, by = .25)

pop_depletion_plot <- outcomes %>%
  filter(year == max(year)) %>%
  ggplot() +
  geom_bin2d(aes(depletion, pop_effect), binwidth = c(.1, .1),
             show.legend = FALSE) +
  scale_fill_viridis(
  option = "A",
  # trans = "log10",
  guide = guide_colorbar(frame.colour = "black",
  frame.linewidth = 1,),
  name = "Median Effect"
  ) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), name = "Depletion") +
  scale_y_continuous(labels = ylabs, breaks = ybreaks, name = "") 


pop_depletion_plot <- outcomes %>%
    filter(year == max(year)) %>%
    mutate(
      rdep = cut(
        depletion,
        breaks = seq(0, 1, by = .2),
        labels = seq(0, .8, by = .2),
        include.lowest = TRUE
      )
      ,
      reff = cut(
        pop_effect,
        breaks = seq(-.6, 1, by = .2),
        labels = seq(-.6, .8, by = .2),
        include.lowest = TRUE
      )
    ) %>%
    group_by(rdep, reff) %>%
    count() %>%
    group_by(rdep) %>%
    mutate(pn = n / sum(n)) %>%
    ungroup() %>%
    mutate(rdep = as.numeric(as.character(rdep)),
           reff = as.numeric(as.character(reff))) %>%
    ggplot(aes(rdep, reff, fill = pn)) +
    geom_tile(show.legend = FALSE) +
    scale_fill_viridis(
      option = "A",
      # trans = "log10",
      guide = hgc,
      name = "% of Sims",
      labels = scales::percent_format(accuracy = 1)
    ) +
    scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                       name = "Depletion",
                       expand = expand_scale(add = c(0,0))) +
    scale_y_continuous(labels = ylabs,
                       breaks = ybreaks,
                       name = "")

  pop_size_plot <- outcomes %>%
    filter(year == max(year)) %>%
    mutate(
      rsize = cut(
        mpa_size,
        breaks = seq(0, 1, by = .2),
        labels = seq(0, .8, by = .2)
      )
      ,
      reff = cut(
        pop_effect,
        breaks = seq(-.6, 1, by = .2),
        labels = seq(-.6, .8, by = .2)
      )
    ) %>%
    group_by(rsize, reff) %>%
    count() %>%
    group_by(rsize) %>%
    mutate(pn = n / sum(n)) %>%
    ungroup() %>%
    mutate(rsize = as.numeric(as.character(rsize)),
           reff = as.numeric(as.character(reff))) %>%
    ggplot(aes(rsize, reff, fill = pn)) +
    geom_tile() +
    scale_fill_viridis(
      option = "A",
      # trans = "log10",
      guide = hgc,
      name = "% of Sims",
      labels = scales::percent_format(accuracy = 1)
    ) +
    scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                       name = "Range in MPA",
                       expand = expand_scale(add = c(0,0))) +
    scale_y_continuous(labels = ylabs,
                       breaks = ybreaks,
                       name = "Conservation Effect") +
    theme(legend.position = "top") +
    labs(title = 'B)')



 pop_facet_effect_plot <- outcomes %>%
  filter(year == max(year)) %>%
   select(pop_effect, mpa_size, depletion) %>%
   gather(measure, value, -pop_effect) %>%
   ggplot() +
   geom_bin2d(aes(value, pop_effect), binwidth = c(.1, .1), show.legend = TRUE) +
  scale_fill_viridis(
  option = "A",
  # trans = "log10",
  guide = hgc,
  name = "# of Sims"
  ) +
   facet_wrap(~measure, labeller = labeller(measure = facet_labels), strip.position = "bottom") +
   scale_x_percent(name = "") +
   scale_y_percent(name = "Pop. Conservation Effect") + 
   theme(legend.position = "top")


  pop_depletion_and_size_plot <- outcomes %>%
    filter(years_protected >= 0) %>%
    group_by(experiment) %>%
    mutate(depletion = plyr::round_any(depletion[years_protected == 0], .1),
           mpa_size = plyr::round_any(mpa_size, .1)) %>%
    filter(year == max(year)) %>%
    group_by(depletion, mpa_size) %>%
    summarise(median_mpa_effect = median(pop_effect, na.rm = TRUE)) %>%
    ggplot(aes(depletion, mpa_size, fill = median_mpa_effect)) +
    geom_tile() +
    # geom_contour(aes(z = median_mpa_effect, color = ..level..), show.legend = FALSE) +
    scale_fill_viridis(labels = scales::percent_format(accuracy = 1),
                       guide = hgc,
                       name = "Median Pop. Effect") +
  labs(x = "Depletion", y = "Range in MPA", title = "A)") +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                       expand = c(0,0)) +
    scale_x_continuous(labels = scales::percent_format(accuracy = 1), expand = c(0,0),
                       limits = c(0,1)) + 
    theme(legend.position = "top")
  
  # pop_depletion_and_size_plot <-  directlabels::direct.label(pop_depletion_and_size_plot, list("angled.boxes", box.alpha = 0.5))


  pop_combo_plot <-
    (pop_depletion_and_size_plot) + ((pop_size_plot) / pop_depletion_plot)  + plot_layout(widths = c(1.5, 1)) & theme(
    plot.margin = unit(c(0, 1, 0, 1), units = "lines"),
    axis.text.x = element_text(size = 8),
    legend.box.margin = unit(c(0, 0, 0, 0), units = "lines"),
    axis.text.y = element_text(size = 10)
    ) 
   
pop_combo_plot

```


<!-- ##### BACI -->

<!-- # ```{r baci-vs-mpa-effect-plot, include = FALSE, eval = FALSE} -->
<!-- #  -->
<!-- # baci_plot <- baci_outcomes %>% -->
<!-- #   filter(sprinkler == FALSE, mpa_habfactor == 1) %>% -->
<!-- #   # select(experiment, -->
<!-- #   #        years_protected, -->
<!-- #   #        mpa_effect, -->
<!-- #   #        adult_movement, -->
<!-- #   #        mpa_size, -->
<!-- #   #        contains("baci")) %>% -->
<!-- #   group_by(experiment) %>%  -->
<!-- #   mutate(b0 = unique(`no-mpa`[year == 1])) %>%  -->
<!-- #   ungroup() %>%  -->
<!-- #   mutate(mpa_effect = (`with-mpa` - `no-mpa`) / b0, -->
<!-- #          baci = baci / b0) %>%  -->
<!-- #   mutate(adult_movement = adult_movement / max(adult_movement)) %>% -->
<!-- #   group_by(experiment) %>%  -->
<!-- #   filter(years_protected == max(years_protected)) %>% -->
<!-- #   ggplot(aes(y = (mpa_effect), x = (baci / b0))) + -->
<!-- #     # geom_hline(aes(yintercept = 0)) +  -->
<!-- #   # geom_vline(aes(xintercept = 0)) +  -->
<!-- #   geom_smooth(method = "lm", se = FALSE) + -->
<!-- #   # geom_abline(aes(slope = 1, intercept = 0), linetype = 2, size = 1.5, color = "red") + -->
<!-- #   geom_point(aes(color = adult_movement, size = mpa_size), alpha = 0.5, show.legend = FALSE)  + -->
<!-- #   # labs(y = "True % Increase in Biomass", x = "% BACI") + -->
<!-- #   scale_color_viridis(guide = wide_hgc, labels = scales::percent_format(accuracy = 1), name = "Fish Movement", -->
<!-- #                       option = "cividis") +  -->
<!-- #   theme(legend.position = "top") -->
<!-- #  -->
<!-- # pdf(file =  "figs/baci.pdf",width = 8, height = 5, useDingbats = TRUE) -->
<!-- # print(baci_plot) -->
<!-- # dev.off() -->
<!-- #  -->
<!-- # ``` -->


<!-- At the extreme sizes of MPAs there is clearly a tension between conservation and fishery goals. However, most MPAs are relatively small (XX), and therefore likely to cover lower percentages of a population as simulated here. A key question then is how do tradeoffs   -->

```{r mpa-tradeoffs, eval = FALSE}

tradeoffs <- fishery_outcomes %>%
  select(experiment, year, years_protected,mpa_size, fishery_effect) %>%
  left_join(outcomes %>%
  select(experiment,year, mpa_effect), by = c("experiment","year")
)


vplot <- tibble(fishery_effect = -1:1, mpa_effect = -1:1) %>%
  mutate(slope = ifelse(fishery_effect < 0, -1, 1)) %>%
  mutate(vline = slope * fishery_effect)

tradeoff_kobe_plot = tradeoffs %>%
  group_by(experiment) %>%
  filter(years_protected == max(years_protected)) %>%
  ungroup() %>%
  mutate(mpa_bin = cut(mpa_size, breaks = seq(0, 1, by = 0.25))) %>%
  ggplot(aes(fishery_effect, mpa_effect)) +
  geom_hline(aes(yintercept = 0), linetype = 2) +
  geom_vline(aes(xintercept = 0), linetype = 2) +
  geom_hex(bins = 5,    aes(fill = ..density..),color = "black") +
    geom_line(data = vplot,aes(fishery_effect, vline), color = "red",
              linetype = 2, size = 2) +

  # geom_abline(aes(slope = -1, intercept = 0), linetype = 2, color = "red", size = 2) +
  #   geom_abline(aes(slope = 1, intercept = 0), linetype = 2, color = "black", size = 2) +
  scale_fill_distiller(
    # option = "plasma",
    labels = scales::percent_format(accuracy = 1),
    name = "% of Sims",
    guide = hgc
  ) +
  # geom_point(size = 2, alpha = 0.2, aes(color = factor(mpa_bin))) +
  # scale_color_viridis_d() +
  facet_wrap( ~ mpa_bin) +
  theme_minimal() +
  theme(legend.position = "top") +
    scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                     name = "% Change Fishery") +
      scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     name = "% Change Conservation") + 
  labs(caption = "facets are percent of range in MPA. Red dashed line shows points where fisheries losses/gains are equal to conservation gains")

# suppose that utility is the sum of percentage gain in conservation and fishery

tradeoff_bins <- tradeoffs %>%
  group_by(experiment) %>%
  filter(years_protected == max(years_protected)) %>%
  mutate(tradeoff = mpa_effect + fishery_effect) %>%
  mutate(tradeoff_bin = plyr::round_any(tradeoff,.25),
         mpa_bin = plyr::round_any(mpa_size,.1)) %>%
  group_by(tradeoff_bin, mpa_bin) %>%
  count() %>%
  group_by(mpa_bin) %>%
  mutate(n = n / sum(n)) %>%
  ungroup()

tradeoff_summary <- tradeoffs %>%
  group_by(experiment) %>%
  filter(years_protected == max(years_protected)) %>%
  mutate(tradeoff = mpa_effect + fishery_effect) %>%
  mutate(mpa_bin = plyr::round_any(mpa_size,.1)) %>%
  group_by(mpa_bin) %>%
  summarise(net_tradeoff = mean(tradeoff > 0))

tradeoff_density_plot <- tradeoff_bins %>%
  ggplot(aes(mpa_bin, tradeoff_bin, fill = n)) +
  # geom_hline(aes(yintercept = 0), linetype = 2, size = 2) +
  geom_tile(alpha = 0.9) +
  scale_fill_viridis(
    option = "plasma",
    labels = scales::percent_format(accuracy = 1),
    name = "% of Sims",
    guide = hgc
  ) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                     name = "% of Range in MPA") +
  scale_y_continuous(name = "Net Utility") +
  theme(legend.position = "top")



tradeoff_summary_plot <- tradeoff_summary %>%
  ggplot(aes(mpa_bin, net_tradeoff)) +
  geom_col() +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                     name = "% of Range in MPA") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     name = "% Positive Utility")

# tradeoff_density_plot + tradeoff_summary_plot & theme(
#     plot.margin = unit(c(0, 1, 0, 1), units = "lines"),
#     axis.text.x = element_text(size = 8),
#     legend.box.margin = unit(c(0, 0, 0, 0), units = "lines"),
#     axis.text.y = element_text(size = 10)
#     )


```

<!-- why is it going to be hard ot detect regional effects of MPAs few if any empirical studies at net regional effects. does this mean that i doesn't exist, or impossible tot est, why? three fundamental stumbling blocks -->



## Estimation Model

The goal of the estimation model is to estimate the difference in the mean densities of targeted and non-targeted species pre-and-post MPA implementation.

### Data

All observation data used in the estimation model were collected by PISCO. PISCO staff also compiled allometric information used to convert lengths to expected weights, and hence biomass densities. We do not account for error in this translation step Table.S\@ref(tab:classcode) lists the species included in the model. In order to be included in the estimation model, a species must have been observed at least twice a year every year for at least 14 years. We also omitted all observations of "young of the year" fish due to inability to identify these observations to the nearest species level in many cases. We omitted data from 1999 due to changes in the sampling procedures that occurred after 1999. Per recommendations from PISCO staff we omit observations from the canopy level of the transects (leaving the middle, bottom, and middle canopy levels). 

PISCO data report positive observations of fish. In order to use these data in our model we need to add in zeros for any transect that could have observed a given species of fish but did not. We assume that a fish could have been observed on a given transect if that species has ever been observed at that site in any time period in the data (PISCO data are organized by sites, with multiple transect at different locations within the borders of a site). If a species has never been observed at a site we assume that it does not occur at that site. 

Interested readers can examine the mean biomass densities of all species in Fig.\@ref(fig:targ-trend-plot)-\@ref(fig:nontarg-trend-plot). 

We include several additional sources of data in our regression analysis. Temperature readings are included from the PISCO data for each transect. We also include PISCO data on the estimated surge and visibility. We augmented these data with information on kelp cover over time from the Santa Barbara Channel Long Term Ecological Research Network [@lter2017]. We used a k-nearest neighbors algorithm to fill in missing kelp observations, and matched the interpolated kelp data to the PISCO data at the resolution of year-month-site (Fig.\@ref(fig:kelp-plot)). 

Temperature data were augmented with data from `FishLife` [@thorson2017c] to include the estimated preferred temperature for a given species, so that we can include deviations from the preferred temperature envelope as a predictor in the model. This allows different temperatures to have different effects on each species (and is less computationally intensive than estimating species-temperature slopes) (Fig.\@ref(fig:tempdev-plot)). 

We also included lagged catch totals in the Santa Barbara region for the commercially harvest species in the database, in an effort to control for changes in density caused by changes in fishing pressure. Catches were pulled from the CDFW website (https://www.wildlife.ca.gov/Fishing/Commercial/Landings), and extracted using the `tabulizer` package in R [@leeper2018] (Fig.\@ref(fig:catches-plot)). 

```{r tempdev-plot, fig.cap = "Mean deviations from preferred temperature by species and year"}


abundance_data$data[[1]] %>% 
  group_by(commonname, year) %>% 
  summarise(mean_tempdev = mean(temp_deviation)) %>% 
  ggplot(aes(year, mean_tempdev)) + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line() + 
  facet_wrap(~commonname, scales = "free_y") + 
  theme_minimal() + 
  labs(x = "Year", y = "Deviation from mean preferred temperature")


```


```{r catches-plot, fig.cap = "Total CDFW reported commercial catches in the Santa Barbara region"}

abundance_data$data[[1]] %>% 
  filter(targeted == 1) %>% 
  group_by(commonname, year) %>% 
  summarise(catches = unique(lag_catch)) %>% 
  group_by(commonname) %>% 
  mutate(total_catches = sum(catches)) %>% 
  ungroup() %>% 
  filter(total_catches > 0) %>% 
  ggplot(aes(year, catches)) + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line() + 
  facet_wrap(~commonname, scales = "free_y") + 
  theme_minimal() + 
  labs(x = "Year", y = "Catch (lbs)")

```


```{r kelp-plot, fig.cap="Mean kelp biomass by island over time from SBC LTER"}

abundance_data$data[[1]] %>% 
  group_by(region,year) %>% 
  summarise(mean_kelp = mean(interp_kelp, na.rm = TRUE)) %>% 
  ggplot(aes(year, (mean_kelp), color = region)) + 
  geom_line() + 
  labs(x = "Year", y = "Mean Kelp Biomass")

```



```{r targ-trend-plot, fig.cap="Centered and scaled mean biomass densities of all targeted finfish in analysis before filtering"}

targeted_trend_plot <- pisco_data %>% 
  filter(targeted == 1) %>% 
  group_by(year, classcode, targeted, commonname) %>% 
  summarise(mean_biomass_density = mean(density_g_m2, na.rm = TRUE)) %>% 
  group_by(classcode) %>% 
  mutate(mean_biomass_density = scale(mean_biomass_density)) %>% 
  ggplot(aes(year,mean_biomass_density)) + 
  geom_hline(aes(yintercept = 0), linetype = 2) + 
  geom_vline(aes(xintercept = 2003), color = "red") +
  geom_line() + 
  facet_wrap(~commonname) +
  theme_minimal() + 
  theme(strip.text = element_text(size = 6),
        axis.text.x = element_text(size = 8)) + 
  labs(x = "Year", y = "Centered and Scaled Mean Biomass Density")

targeted_trend_plot
```

```{r nontarg-trend-plot, fig.cap="Centered and scaled mean biomass densities of all non-targeted finfish in analysis before filtering"}

nontargeted_trend_plot <- pisco_data %>% 
  filter(targeted == 0) %>% 
  group_by(year, classcode, targeted, commonname) %>% 
  summarise(mean_biomass_density = mean(density_g_m2, na.rm = TRUE)) %>% 
  group_by(classcode) %>% 
  mutate(mean_biomass_density = scale(mean_biomass_density)) %>% 
  ggplot(aes(year,mean_biomass_density)) + 
  geom_hline(aes(yintercept = 0), linetype = 2) + 
  geom_vline(aes(xintercept = 2003), color = "red") +
  geom_line() + 
  facet_wrap(~commonname) +
  theme_minimal() + 
  theme(strip.text = element_text(size = 6),
        axis.text.x = element_text(size = 8)) + 
  labs(x = "Year", y = "Centered and Scaled Mean Biomass Density")

nontargeted_trend_plot
```


```{r classcode}

species_data <- cip_data %>% 
  select(classcode, commonname, taxa, targeted) %>% 
  unique() %>% 
  arrange(desc(targeted)) %>% 
  mutate(targeted = targeted == 1) %>% 
  rename(`Common Name` = commonname, 
         `Scientific Name` = taxa,
         `Targeted?` = targeted)

status <- read_csv(here::here("data","stock-status-summaries.csv")) %>% 
  select(classcode, `Stock Status`)

species_data <- species_data %>% 
  left_join(status, by = "classcode")

knitr::kable(species_data,
             digits = 2,
             caption = "Species included in estimation model",
             longtable = TRUE,
             booktabs = TRUE,
             col.names = colnames(species_data)) %>%
  kableExtra::kable_styling(latex_options = c("hold_position", "repeat_header"))


```

### Model

The regression analysis uses a mixed-effects hierarchical model. The raw data are estimated length compositions by fish species along a survey transect at a site. Lengths are converted to biomass per allometric relationships supplied by PISCO and supplemented by the `FishLife` [@thorson2017c] package in R where needed. We performed some minimal data filtering to reduce noise in the data. We only include species that were observed at least twice in each year of the dataset (2000-2017) somewhere in the core Channel Islands (Anacapa, Santa Cruz, Santa Rosa, San Miguel). While some data are available from 1999, per consultation with PISCO we omit those data due to changes in survey protocols. We assign species to targeted and non-targeted groups per the PISCO classifications. This filtering process results in `r filter_summary$no` non-targeted species and `r filter_summary$yes` targeted species remaining in the analysis. 

The simplified explanation of the estimation is a hierarchical model in which we first standardize the observed biomass densities into an abundance index of each species over time. The abundance indices in each year are assumed to be log-normally distributed with means and standard deviations for the targeted and non-targeted groups, giving an estimate of the mean densities of targeted and non-targeted species over time. We then calculate the difference between mean density of targeted species and the mean density of non-targeted species in each year.

\newpage
```{r cartoon, fig.cap= "Cartoon illustration of the hierarchichal difference-in-difference estimator", fig.width=3}
knitr::include_graphics("figs/estimation-cartoon.png")
```

\pagebreak


The first stage of the regression is a log-normal delta model. The model estimates two regressions, the first is a binomial generalized linear model (GLM) with a logit link estimating the probability of observing a given fish species at a observation *i* (transect at time *t*). The probability that a given species was observed *o* at a given observation is distributed

\begin{equation}
o_{s,i} \sim binomial(\frac{1}{1 +e^{-\beta^{o}{X}}})
  (\#eq:binom)
\end{equation}

 where $\beta^{o}$ are the estimated coefficients for the observation model and *X* is a matrix of covariates that include random effects for each year in the data (2000 to 2017). 
 
The expected density *d* of positive observations is modeled per a log-normal distribution
 
 \begin{equation}
  log(d_{s,i}) \sim normal(\beta^{d}X, \sigma_s)
   (\#eq:logd)
 \end{equation}
 

where $\beta^{d}$ are the estimated coefficients for the expected density model and *X* is the same matrix of covariates as used in the observation portion of the model and $\sigma_s$ allows for each species *s* to have different standard deviations. 

Our covariate matrix *X* contains both fixed and random effects. Fixed effects include the depth level of the transect, the sampling site, the month of the observation, the estimated surge at the transect, visibility, the depth of the transect, and the experience (and experience squared) of the diver conducting the transect. We classify each species into one of two clusters based on the mean longitude the species was encountered at, breaking the species into two groups: those primarily found in the western end of the Channel Islands those found more in the eastern end.  We then estimate random effects for each island for each cluster


\begin{equation}
\beta_{island,cluster} \sim normal(0,\sigma_{cluster})
  (\#eq:island)
\end{equation}

This allows the mean effect of each island to differ for each cluster, e.g. allowing San Miguel, the easternmost island, to have a higher mean density for eastern species than for more western species (if the data suggest it). 

The second critical component of the covariate matrix *X* are random effects for each year for each species

\begin{equation}
  \beta_{year,species} \sim normal(0,\sigma_{species})
  (\#eq:species)
\end{equation}


These $\beta_{year,species}$ represent our "standardized" estimate of observed abundance of each species in each time step, controlling for the included covariates. 

However, we still need to account for changes in the probability of detection over time. For that, we create a standard matrix of with rows equal to the number of years and columns corresponding to each of the columns in *X*, holding everything fixed at mean (or most frequently observed level for factors) levels for all variables in X except for the year and species interaction indices. Calling this standardized matrix $X^{standard}$, the probability of observing a given species in year *y* is then

\begin{equation}
p_{s,y} = (\frac{1}{1 +e^{-\beta^{o}{X^{standard}}}})
  (\#eq:pdetect)
\end{equation}


In the same manner as described by @punt2000, The standardized index of abundance for species *s* in year *y* then is


\begin{equation}
I_{species,year} = p_{species,year}e^{\beta_{species,year}}
  (\#eq:index)
\end{equation}


The next phase of the model requires us to estimate the mean abundance of targeted and non-targeted species over time. The concept here is that each $I_{species,year}$ can be modeled by a regression that contains random effects for each year for targeted and non-targeted fishes, the assumption then being that there is a mean density for targeted and non-target species, and $I_{species,year}$ represent deviations from that mean. 

\begin{equation}
log(I_{species,year}) \sim normal(\beta^{effect}X^{effect}, \sigma_I)
  (\#eq:indexprior)
\end{equation}


$X^{effect}$ contains both fixed and random effects. The fixed effects include an intercept and the temperature deviation for a given species in a year, where temperature deviation is

\begin{equation}
t_{s,y} = (t^{pref}_{s} -  \bar{t_{y}})^2
  (\#eq:tempdev)
\end{equation}


where $t^{pref}$ is the preferred temperature for species *s* (drawn form `FishLife`, @thorson2017c), and $\bar{t_{y}}$ is the mean temperature encountered by that species in year *y*. We also include as variables in the model the mean kelp cover experienced by a given species in a given year, as well as the total fishery catches reported in the previous year for that species in the Santa Barbara region [drawn from the California Department of Fish and Wildlife database].  We also include random intercepts for each species in $X^{effect}$. The most important random effects are year effects for targeted and non-targeted species

\begin{equation}
\beta_{year,targeted} \sim normal(0,\sigma_{targeted})
  (\#eq:betatarg)
\end{equation}

$\beta_{year,targeted}$ is the mean log density of targeted species in year *y*, controlling for included covariates. Therefore, the final step in the model, the divergence in the standardized abundance trends of targeted and non-targeted species is


\begin{equation}
divergence_{year} =  \beta_{year,targeted = 1} - \beta_{year,targeted = 0}
  (\#eq:mpaeffect)
\end{equation}

The model is fit in TMB to integrate the uncertainty across all levels of the model, with standard errors for each coefficient in the model estimated through the Laplace approximation. 

A complete table of estimated coefficients can be seen in Table.S\@ref(tab:betatable).

<!-- Stock status estimates are not available for many of the targeted species in the database. The California Department of Fish and Wildlife compiles status estimates for many nearshore finfish (https://www.wildlife.ca.gov/Conservation/Marine/Groundfish/Nearshore-Finfish), including recent stock assessments.  For species not listed here we searched for available information on recent stock status from relevant stock assessments.  -->

```{r betatable}

table <- betas %>% select(-std_error,-group)

knitr::kable(table,
             digits = 2,
             caption = "Complete table of estimated coefficients from hierarchical difference-in-difference model",
             longtable = TRUE,
             booktabs = TRUE,
             col.names = colnames(table)) %>% 
  kableExtra::kable_styling(latex_options = c("hold_position", "repeat_header"))


```


Figures S\@ref(fig:fe-plot):S\@ref(fig:targ-plot) present estimated effects for covariates included in the model, along with the raw estimated mean trends of the targeted and non-targeted species (while the difference between these trends is presented in our main results).

\newpage

```{r fe-plot, fig.cap = "Estimated coefficients for non-spatial fixed effects in observation model (seeing) and observed model (seen)"}

 non_nested_beta_plot <- betas %>%
   filter(str_detect(group, "non_nested") & !str_detect(variable, "site_side")) %>%
   ggplot() +
   geom_hline(aes(yintercept = 0), linetype = 2, color = "red") +
   geom_pointrange(aes(x =variable,
                       y = estimate,
                       ymin = lower,
                       ymax = upper)) +
   facet_wrap(~group, labeller=labeller(group=c(
     seeing_non_nested_betas="Observation Model\n(seeing)",
     seen_non_nested_betas = "Observed Model\n(seen)"
   ))) +
   coord_flip() +
   theme(axis.text.y = element_text(size = 10))

non_nested_beta_plot

```

\pagebreak



```{r site-plot, fig.cap = "Estimated coefficients for spatial random effects in observation model (seeing) and observed model (seen)", fig.height=10}

 non_nested_site_beta_plot <- betas %>%
   filter(str_detect(group, "non_nested") & str_detect(variable, "site_side")) %>%
  mutate(variable = tolower(variable)) %>% 
  mutate(variable = str_replace(variable, "site_side","")) %>% 
  mutate(island = str_replace(str_split(variable, '_', simplify = TRUE)[,1],'-','')
 ) %>% 
   ggplot() +
   geom_hline(aes(yintercept = 0), linetype = 2, color = "red") +
   geom_pointrange(aes(x = variable,
                       y = estimate,
                       ymin = lower,
                       ymax = upper)) +
   facet_grid(island~group, scales = "free",labeller=labeller(group=c(
     seeing_non_nested_betas="Observation Model\n(seeing)",
     seen_non_nested_betas = "Observed Model\n(seen)"),
     island=c(anacapa="ANA",sci="SCI",smi="SMI",sri="SRI"))) +
   coord_flip() +
   theme(axis.text.y = element_text(size = 10)) + 
  theme_minimal()

non_nested_site_beta_plot + 
  theme(axis.text.y = element_text(size = 6))

```

\pagebreak



```{r region-plot, fig.cap="Random effects for region by cluster", eval = FALSE}

  region_cluster_plots <- betas %>%
   filter(str_detect(group, "region_cluster_betas")) %>%
   mutate(cluster = str_replace_all(variable,"\\D","")) %>%
   mutate(region = str_split(variable,'-', simplify = T)[,3]) %>%
   ggplot() +
    geom_hline(aes(yintercept = 0), linetype = 2, color = "red") +
    geom_pointrange(aes(x = region,
                        y = estimate,
                        ymin = lower,
                        ymax = upper, color = cluster)) +
    facet_wrap(~group,labeller=labeller(group=c(
     seeing_region_cluster_betas="Observation Model\n(seeing)",
     seen_region_cluster_betas = "Observed Model\n(seen)")))

region_cluster_plots

```

\pagebreak

```{r targ-plot, fig.cap = "Trends in standardized mean abundance of targeted and non-targeted species"}

targeted_trends <- report$zissou_estimates %>% 
  filter(str_detect(variable, "targeted_did")) %>% 
  group_by(variable) %>% 
  mutate(year =zissou_fit$did_data$year %>% unique(),
         labvar=ifelse(variable=="nontargeted_did_betas","Nontargeted","Targeted")) %>% 
  ungroup() %>% 
  ggplot() + 
  geom_line(aes(year, estimate, color = labvar),alpha = 0.5) +
  geom_pointrange(aes(year, estimate, ymin = lower, ymax = upper, color = labvar)) + 
  scale_color_d3(name = "") +
  theme(legend.position = c(0.8,0.9))


targeted_trends

```

\pagebreak

### Regression Diagnostics

We include visual diagnostics of our estimation model. All coefficients passed convergence criteria for TMB.


Looking first at the predictions of the model for the positive observations in the data (i.e. using the full model to predict biomass densities, and then comparing those predictions to cases where some positive biomass densities were observed), the model diagnostics show no clear problems. The $R^2$ of the model is 0.43. Residuals do not exhibit trends, though some grouping the residuals is evident. The quantile-quantile plot suggest that on the assumption of log-normal errors on the observed densities is reasonable, though the model appears to have some slight problems estimating the highest observed densities (Fig.S\@ref(fig:obs-v-pred-plot)).


```{r}

fit_report <- base_run$tmb_fit[[1]]$zissou_report

observed_seen <- base_run$tmb_fit[[1]]$zissou_data$log_density
  
observed_seeing <- base_run$tmb_fit[[1]]$zissou_data$any_seen

seen_diagnostics <- data_frame(observed = observed_seen, predicted = as.numeric(fit_report$log_density_hat)) %>% 
  mutate(residuals = predicted - observed)


seeing_diagnostics <- data_frame(observed = observed_seeing, predicted = as.numeric(fit_report$prob_seeing)) 

```


```{r, eval = FALSE}

a = base_run$tmb_fit[[1]]$zissou_data$x_seen_non_nested %>% 
  as_data_frame() %>% 
  select(contains("mean_")) %>% 
  mutate(resid = seen_diagnostics$residuals) %>% 
  gather(variable, value, -resid) %>% 
  ggplot(aes(value, resid)) + 
  geom_point() + 
  facet_wrap(~variable)

a

```


```{r obs-v-pred-plot, fig.cap="High level diagnostics for observed compontent of Delta-GLM: Observed vs predicted log densities (A), predicted log density vs residuals (B), and a normal qq-plot of the residuals (C)"}

obs_v_pred_plot <- seen_diagnostics %>% 
  ggplot(aes(observed, predicted)) + 
  geom_point(alpha = 0.5) + 
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2, color = "red") + 
  labs(caption = glue::glue("R^2 is {round(yardstick::rsq(data = seen_diagnostics, truth = observed, estimate = predicted)$.estimate,2)}"), title= "A") + 
  theme(plot.margin = unit(rep(.1,4), units = "lines"))

fit_v_resid_plot <- seen_diagnostics %>% 
  ggplot(aes(predicted, residuals)) + 
  geom_point() + 
  geom_hline(aes(yintercept = 0), linetype = 2, color = "red") + 
  labs(title = "B") +
    theme(plot.margin = unit(rep(.1,4), units = "lines"))

qq_plot <- ggplot(seen_diagnostics, aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line() + 
  labs(title = "C") + 
    theme(plot.margin = unit(rep(.1,4), units = "lines"))


obs_v_pred_plot/(fit_v_resid_plot + qq_plot)


```



In order to evaluate the ability of the model to estimate positive observations, we can compare the the binned predicted probability of a positive observation to the proportion of observations in that bin that recorded positive observations. If our model is working well, we would expect a group of fisheries that our model estimates on average should have a 50% probability of a positive observation, then we should expect about 50% of those observations to have positive observations. This is indeed what we see from the model (Fig.S\@ref(fig:obs-prob-plot)).


```{r obs-prob-plot, fig.cap = "Binned mean predicted probability of detection provided by the first stage of the hurdle model vs observed proportion of positive detections"}

seeing_diag_plot <- seeing_diagnostics %>% 
  ungroup() %>% 
  mutate(binned_prob = ntile(predicted, 20)) %>% 
  arrange(binned_prob) %>% 
  group_by(binned_prob) %>% 
  summarise(mean_prob_seen = mean(predicted),
            percent_observed = mean(observed))  %>% 
  ggplot() +
  geom_point(aes(mean_prob_seen, percent_observed)) + 
  geom_abline(aes(intercept = 0, slope = 1), color = "red", linetype = 2) + 
  labs(x = "Binned Predicted Probability of Detection", y = "Proportion of Positive Observations")

seeing_diag_plot
```


We can also examine the receiver-operator-curve (ROC) to assess the performance of the observation component of the model. The area under the curve (AUC) value for the model is 0.84 (on a scale of 0.5 to 1), indicating the model is an overall good predictor of whether or not a given observation of biomass densities will be positive or not. 


```{r roc-plot, fig.cap = "Receiver operating characteristic curve of predictions of positive biomass densities"}
library(plotROC)
rocplot <- ggplot(seeing_diagnostics, aes(m = predicted, d = observed))+ geom_roc(n.cuts=20,labels=FALSE) + 
  geom_abline(aes(slope = 1, intercept = 0))

roc_plot <- rocplot + style_roc(theme = zissou_theme) 

roc_plot
```

### Standardized Abundance Indices 

Overall most species showed consistent trends in biomass densities across the different islands at which they have been observed (Fig.S\@ref(fig:reg-pop)).  

```{r reg-pop, fig.cap = "Mean density by island by year for each fish species included in the analysis"}

reg_pop_plot <- fitted_data %>% 
  group_by(region, year, classcode) %>% 
  summarise(mean_density = mean(exp(log_density))) %>% 
  mutate(log_mean_density = log(mean_density)) %>% 
  ungroup() %>% 
  group_by(classcode, region) %>% 
  mutate(cs_mean_density = (mean_density - mean(mean_density)) / sd(mean_density)) %>% 
  ungroup() %>% 
  ggplot(aes(year, cs_mean_density, color = region)) + 
  scale_color_npg(name="Region")+
  geom_line() + 
  labs(y="Centered and Scaled Density",x="Year")+
  facet_wrap(~classcode, scales = "free_y") + 
  theme_minimal()+
  theme(axis.text=element_text(size=6))

reg_pop_plot

```

The standardized indices of abundance generally did not very substantially from the raw mean densities by species over time. However, for some species, such as blue rockfish, the standardized abundance index suggests much higher biomass densities in the pre-MPA period than those reported in the raw data. We suspect this is largely a function of changes in sampling sites over time, that the standardization is better able to account for (Fig.S\@ref(fig:raw-v-stand-plot)). 


```{r raw-v-stand-plot, fig.cap = "Raw (points) and standardized (lines) indices of abundance for each of the fishes included in the analysis"}


life_history <- fitted_data %>%
  select(classcode) %>%
  unique() %>%
  mutate(numeric_classcode = as.numeric(as.factor(classcode)))

raw <- fitted_data %>%
  group_by(year, classcode, targeted) %>%
  summarise(md = mean(exp(log_density)),
            mt = mean(temp_deviation)) %>%
  group_by(classcode) %>%
  mutate(smd = (md - mean(md))/(sd(md))) %>%
  ungroup() %>%
  left_join(life_history, by = "classcode")

years <- unique(fitted_data$year)

years <- zissou_fit$did_data$year %>% unique()

abundance_trends <- data_frame(abundance_hat = fit_report$abundance_hat,
                               classcode = rep(1:n_distinct(fitted_data$classcode), each = length(years))) %>%
  mutate(log_abundance_hat = log(abundance_hat)) %>%
  group_by(classcode) %>%
  mutate(year = years) %>%
  mutate(scaled_abundance_hat = (abundance_hat - mean(abundance_hat)) / sd(abundance_hat)) %>%
  ungroup() %>%
  rename(numeric_classcode = classcode) %>%
  left_join(life_history, by = "numeric_classcode" )


# 
# abundance_trends %>%
#   ggplot(aes(year, log(abundance_hat), color = factor(classcode))) +
#   geom_line(show.legend = F) +
#   geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
#   facet_wrap(~classcode) +
#   theme_minimal()

raw_v_std_plot <- abundance_trends %>%
  filter(year %in% years) %>% 
  ggplot(aes(year, scaled_abundance_hat, color = factor(classcode))) +
  geom_line(show.legend = F) +
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_point(data = raw,aes(year, smd, color = factor(classcode)), show.legend = F)+
  facet_wrap(~classcode) +
  labs(y="Raw (dots) and Standardized (lines) Abundance",x="Year")+
  theme_minimal()+
  theme(axis.text=element_text(size=6))

raw_v_std_plot

```


We include a variety of environmental, observation, and temporal indicators in our model. Inclusion of highly co-linear variables in a model can inflate standard errors and obscure "true" effects. To account for this we calculated the Pearson's correlation coefficients for all of the continuous data included in our model to ensure that none of the included variables had correlation coefficients greater than 0.7, a general rule of thumb for co-inclusion of variables. We did not find problematic levels of correlation among any of our included continuous variables. 

```{r numeric-cor, fig.cap="Pearson correlation coefficients of continuos data included in the regression model"}

numeric_cor_plot <- base_run$data[[1]] %>%
  select_if(is.numeric) %>%
  select(-log_density, -targeted) %>%
  na.omit() %>%
  corrr::correlate() %>%
  gather("colname", "correlation", -rowname) %>%
  ggplot(aes(rowname, colname, fill = correlation)) +
  geom_tile() +
  geom_text(aes(rowname, colname, label = round(correlation, 2))) +
  scale_fill_gradient2(
    low = "tomato",
    mid = "white",
    high = "steelblue",
    midpoint = 0,
    limits = c(-1, 1)
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(
      angle = 45,
      vjust = 1,
      hjust = 1,
    size = 6),
    axis.text.y = element_text(size = 6),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

numeric_cor_plot
```


## Alternative estimation models

Our proposed identification strategy attempts to control for non-MPA (and not directly modeled) related changes in abundances through the trend in the non-targeted species. However, a simpler alternative would be to simply compare densities before-and-after MPA implementation, while explicitly controlling for non-MPA related factors that we believe may have some effect on densities (a "selection on observables" strategy). To that end, we fit a mixed-effects regression that models log densities of targeted species only (positive observations only, for the sake of simplicity) as a function of temperature deviations, kelp cover, observer experience, random effects for species and region, and fixed effects for each year in the data (omitting the year 2000). The hypothesis here is that any non-MPA related factors that affect densities are accounted for in the observed variables included in the model. 

Using this model, densities of targeted species appear to have been declining steadily since 2000, and appear to have plateaued off since the implementation of MPAs in 2003. Without an identification strategy such as the one employed in this study then, all we could conclude is that densities appear to be lower post-MPA, and have not increased substantially over time (Fig.S\@ref(fig:obs-plot)).  


```{r obs-plot, fig.cap = "Selection on observables identification strategy. Plotted estimates are fixed effects of year on log-density (relative to the year 2000), controlling for observer experience, temperature deviations, and kelp cover, with random effects for species and region"}

test <- lme4::lmer(log_density~ factor_year + cumulative_n_obs  + temp_deviation + interp_kelp + (1|classcode) + (1|region), data = fitted_data %>% filter(targeted == 1, any_seen == T))

sel_on_obs_plot <- broom::tidy(test) %>% 
  filter(str_detect(term, "factor_year")) %>% 
  mutate(year = str_replace_all(term,"\\D","") %>% as.numeric()) %>% 
  ggplot() + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_pointrange(aes(year, estimate, ymin = estimate - 1.96*std.error, ymax = estimate + 1.96*std.error)) + 
  labs(y = "Estimated Difference", x = "Year")


sel_on_obs_plot
```



```{r, include=F}
raw <- fitted_data %>%
  group_by(year, classcode, region, targeted) %>%
  summarise(md = mean(exp(log_density)),
            mt = mean(temp_deviation)) %>%
  group_by(classcode) %>%
  mutate(smd = (md - mean(md))/(sd(md))) %>%
  ungroup() %>%
  left_join(life_history, by = "classcode")

raw_region <- fitted_data %>%
  group_by(year, region,classcode, targeted) %>%
  summarise(md = mean(exp(log_density)),
            mt = mean(temp_deviation)) %>%
  group_by(classcode) %>%
  mutate(smd = (md - mean(md))/(sd(md))) %>%
  ungroup() %>%
  left_join(life_history, by = "classcode")


raw_mpa_only <- fitted_data %>%
  filter(eventual_mpa == T) %>% 
  group_by(year, classcode, targeted) %>%
  summarise(md = mean(exp(log_density)),
            mt = mean(temp_deviation)) %>%
  group_by(classcode) %>%
  mutate(smd = (md - mean(md))/(sd(md))) %>%
  ungroup() %>%
  left_join(life_history, by = "classcode")

raw_nompa_only <- fitted_data %>%
  filter(eventual_mpa == F) %>% 
  group_by(year, classcode, targeted) %>%
  summarise(md = mean(exp(log_density)),
            mt = mean(temp_deviation)) %>%
  group_by(classcode) %>%
  mutate(smd = (md - mean(md))/(sd(md))) %>%
  ungroup() %>%
  left_join(life_history, by = "classcode")

# basic_model <- rstanarm::stan_glm(log(md + 1e-3) ~ factor(year) + targeted + factor(year):targeted, data = raw)


```


The estimation model used for our main results is complicated. We feel this complexity is justified in order to best capture the uncertainty inherent in the challenging task of conducting underwater visual surveys, as well as the spatio-temporal nature of the underlying data. However, we also ran several simpler models in order to examine the sensitivity of our results to the model structure selected here. 

Much of the complexity of our model comes from the integration of a standardized abundance index for each of the species, which are then compiled into a standardized index of abundance index for targeted species as a whole. 

In one simpler approach, we aggregated the PISCO data into mean biomass densities by species and year across all the Channel Islands. Since all included species have at least some positive observations in each year, this removes the complication of dealing with the probability of detection problem in the raw data, while of course assuming that the net effects of all of the other factors included in our main model are on average zero (e.g. observer skill, visibility, etc.). A difference-in-difference model fit to these simplified data show qualitatively similar (though much more uncertain) results to our full model. In particular, the model shows the same gradual increase in targeted densities relative to non-targeted until 2013, followed by an attenuation of this trend. Importantly, though, this simplified model fails to correct for some pre-MPA differences in the two groups, leading to negative "effects" of the MPAs being estimated before the MPAs themselves went in place. While these sort of anticipatory effects are certainly possible [@mcdermott2019], in this case we would suggest the likelier explanation---given that these anticipatory effects disappear in the full model---is that our full model provides important controls for pre-MPA characteristics (Fig.S\@ref(fig:sortasimple-did))


```{r, results = "hide"}

year_mpa <- 2002

  data <- abundance_data$data[abundance_data$data_source == "pisco"][[1]] %>%
    mutate(density = exp(log_density) * any_seen) %>%
    mutate(targ = case_when(targeted == 1 ~ "Targeted",  TRUE ~ "Non-Targeted"))

  sortasimple <- data %>%
    group_by(year, classcode) %>%
    summarise(mean_density = mean(density),
              targ = unique(targ)) %>%
    mutate(mpa = year > year_mpa) %>%
    ungroup() %>%
    mutate(fyear = factor(year)) %>%
    mutate(fyear = relevel(fyear, ref = "2003"))


  sortasimple_reg <-
    rstanarm::stan_glmer(
      log(mean_density + 1e-3) ~ targ * fyear + (1 |
                                                   classcode),
      data = sortasimple,
      cores = 4
    )

  sortasimple_plot <- bayesplot::mcmc_areas(as.matrix(sortasimple_reg),
                                            regex_pars = ":fyear") +
    geom_vline(aes(xintercept = 0), linetype = 2, color = "red") +
    scale_y_discrete(labels = c(2000:2001, 2003:2017)) +
    coord_flip() +
    scale_x_percent() + 
    zissou_theme + 
    labs(x="Estimated Difference",y="Year")+
    theme(axis.text.x = element_text(size = 8))


```
```{r sortasimple-did, fig.cap = "Results of simplified difference-in-difference regression. The model estimates the difference in the mean trend of densities of targeted and non-targeted species over time, controlling for the mean densities of each individual species group. Data are initially aggregated to the level of species-by-year."}
sortasimple_plot
```


```{r species-by-species-did, results = "hide"}

year_mpa <- 2002

  data <- abundance_data$data[abundance_data$data_source == "pisco"][[1]] %>%
    mutate(density = exp(log_density) * any_seen) %>%
    mutate(targ = case_when(targeted == 1 ~ "Targeted",  TRUE ~ "Non-Targeted"))

  sortasimple <- data %>%
    group_by(year, classcode) %>%
    summarise(mean_density = mean(density),
              targ = unique(targ)) %>%
    mutate(mpa = year > year_mpa) %>%
    ungroup() %>%
    mutate(fyear = factor(year)) %>%
    mutate(fyear = relevel(fyear, ref = "2003"))


  sortasimple_reg <-
    rstanarm::stan_glmer(
      log(mean_density + 1e-3) ~ targ * fyear + (1 |
                                                   classcode),
      data = sortasimple,
      cores = 4
    )

  sortasimple_plot <- bayesplot::mcmc_areas(as.matrix(sortasimple_reg),
                                            regex_pars = ":fyear") +
    geom_vline(aes(xintercept = 0), linetype = 2, color = "red") +
    scale_y_discrete(labels = c(2000:2001, 2003:2017)) +
    coord_flip() +
    scale_x_percent() + 
    zissou_theme + 
    labs(x="Estimated Difference",y="Year")+
    theme(axis.text.x = element_text(size = 8))


```


As an even simpler approach, we aggregated the data to the level of targeted and non-targeted species, and estimated the divergence in their trends over time.

```{r, results = "hide"}


  data <- abundance_data$data[abundance_data$data_source == "pisco"][[1]] %>%
    mutate(density = exp(log_density) * any_seen) %>%
    mutate(targ = case_when(targeted == 1 ~ "Targeted",  TRUE ~ "Non-Targeted"))

  supersimple <- data %>%
    group_by(year, targ) %>%
    summarise(mean_density = mean(density)) %>% 
    mutate(mpa = year > year_mpa) %>%
    ungroup() %>%
    mutate(fyear = factor(year)) %>%
    mutate(fyear = relevel(fyear, ref = "2002"))


  supersimple_reg <-
    rstanarm::stan_glm(
      log(mean_density) ~ targ + fyear + targ:fyear,
      data = supersimple,
      cores = 4,
      iter = 2000,
      adapt_delta = 0.95
    )
  
    # supersimple_reg <-
    # rstanarm::stan_glm(
    #   log(mean_density + 1e-3) ~ targ * fyear,
    #   data = supersimple,
    #   cores = 4,
    #   iter = 10000
    # )


  supersimple_plot <- bayesplot::mcmc_areas(as.matrix(supersimple_reg),
                                            regex_pars = ":fyear") +
    geom_vline(aes(xintercept = 0), linetype = 2, color = "red") +
    scale_y_discrete(labels = c(2000:2001, 2003:2017)) +
    coord_flip() +
    scale_x_percent() + 
    zissou_theme + 
    labs(y="Year",x="Estimated Difference")+
    theme(axis.text.x = element_text(size = 8))

```

```{r}
supersimple_plot
```


We can also explore the effects of our species filtering by running a simplified regression but now including all the species in the database, no matter of how infrequently they are observed. 

```{r, results= "hide"}
year_mpa <- 2002

  sortasimple <- pisco_data %>%
    group_by(year, classcode) %>%
    summarise(mean_density = mean(density_g_m2, na.rm = TRUE),
              targ = unique(targeted)) %>%
    mutate(mpa = year > year_mpa) %>%
    ungroup() %>%
    mutate(fyear = factor(year)) %>%
    mutate(fyear = relevel(fyear, ref = "2003")) 


  sortasimple_reg <-
    rstanarm::stan_glmer(
      log(mean_density + 1e-3) ~ targ * fyear + (1 |
                                                   classcode),
      data = sortasimple,
      cores = 4
    )

  all_species_sortasimple_plot <- bayesplot::mcmc_areas(as.matrix(sortasimple_reg),
                                            regex_pars = ":fyear") +
    geom_vline(aes(xintercept = 0), linetype = 2, color = "red") +
    scale_y_discrete(labels = c(1999:2001, 2003:2017)) +
    coord_flip() +
    scale_x_percent() + 
    zissou_theme + 
    labs(x="Estimated Difference",y="Year")+
    theme(axis.text.x = element_text(size = 8))
```

```{r sortasimple-noilter-did, fig.cap = "Results of simplified difference-in-difference regression including all observed finfish. The model estimates the difference in the mean trend of densities of targeted and non-targeted species over time, controlling for the mean densities of each individual species group. Data are initially aggregated to the level of species-by-year."}
all_species_sortasimple_plot
```


### Synthetic controls

Synthetic controls are an alternative method for attempting to estimate the causal effect of a policy intervention [@abadie2010]. A difference-in-difference approach assumes that some observable group serves as an adequate control for the state of the treated group in an untreated world. In our default case, we assume that the mean standardized index of non-targeted species are our control for the targeted species. Alternatively, synthetic controls use timeseries of treated and non-treated groups before and after treatment to construct a new "control" group built by weighting the pre-treatment timeseries of un-treated observations (together with covariates) such that the synthetic control group matches the trends in the treated group pre-treatment. 


We chose to present difference-in-difference as our main result since it better allows us to capture the uncertainty in the data generating process through our hierarchical model. However, we felt that it was worth exploring whether synthetic controls provided substantially different results than our default model. 

For the first synthetic control, we pulled our standardized mean index of abundance for targeted species as a whole from our difference-in-difference model as our treated group. We then pull the standardized indices of abundance for each of the non-targeted groups from the difference-in-difference to use as the candidate untreated components for the synthetic controls. A complete synthetic control analysis would require more extensive validation of the methods, but we use this approach simply to explore whether we observe substantially divergent results in the synthetic control versus the difference-in-difference model. 

We centered and scaled the candidate abundance indices to facilitate model convergence given the very few number of pre-treatment years available. The results of a synthetic control model are presented as the difference between the observed treatment outcome and the synthetic control (the difference in this case being in units of standard deviations). The model was not able to construct an adequate synthetic control at this level, as shown by the differences between the treated group and the synthetic control pre-treatment. However, we would note that the post-treatment results do show similarities with our main results, namely a lack of a clear divergence between the treatment and the control, and an upwards trend up through the earl 2010s followed by a decline (Fig.S\@ref(fig:total-synth)). 


```{r, include = FALSE}

nontargeted_index <- data_frame(abundance_hat = fit_report$abundance_hat,
                               classcode = rep(1:n_distinct(fitted_data$classcode), each = length(years))) %>%
  mutate(log_abundance_hat = log(abundance_hat)) %>%
  group_by(classcode) %>%
  mutate(year =years) %>%
  mutate(scaled_abundance_hat = (abundance_hat - mean(abundance_hat)) / sd(abundance_hat)) %>%
  ungroup() %>%
  rename(numeric_classcode = classcode) %>%
  left_join(life_history, by = "numeric_classcode" ) %>% 
  left_join(unique(abundance_data$data[[1]] %>% select(classcode, targeted)), by = "classcode") %>% 
  filter(targeted == 0) %>% 
  select(log_abundance_hat, year, classcode, targeted)


targeted_index <- zissou_fit$zissou_estimates %>%
  filter(
    stringr::str_detect(variable, "(targeted_did_betas)"),!str_detect(variable, "non")
  ) %>%
  mutate(
    year = years,
    classcode = "targeted",
    targeted = 1
  ) %>%
  rename(log_abundance_hat = estimate) %>% 
  select(colnames(nontargeted_index))

  # filter(variable == "seeing_year_species_betas") %>%


nontargeted_covariates <- pisco_data %>% 
  select(classcode, contains("mean"),year, targeted) %>% 
  filter(targeted == 0) %>% 
  select(-mean_length) %>% 
  gather(variable, value, -classcode,-year,-targeted) %>% 
  group_by(classcode, variable, year) %>% 
  summarise(mean_value = mean(value, na.rm = TRUE)) %>% 
  spread(variable, mean_value)

targeted_covariates <- pisco_data %>% 
  select(classcode, contains("mean"),year, targeted) %>% 
  filter(targeted == 1) %>% 
  mutate(classcode = "targeted") %>% 
  select(-mean_length) %>% 
  gather(variable, value, -classcode,-year,-targeted) %>% 
  group_by(classcode, variable, year) %>% 
  summarise(mean_value = mean(value, na.rm = TRUE)) %>% 
  spread(variable, mean_value)


synth_covariates <- nontargeted_covariates %>% 
  bind_rows(targeted_covariates) 

synth_data <- targeted_index %>% 
  bind_rows(nontargeted_index) %>% 
  left_join(synth_covariates, by = c("classcode","year")) %>% 
    mutate(numeric_classcode = as.numeric(factor(classcode))) %>% 
  group_by(classcode) %>% 
  mutate(log_abundance_hat = scale(exp(log_abundance_hat))) %>% 
  ungroup() %>% 
  as.data.frame()


# synth_data %>%
#   group_by(classcode) %>%
#   mutate(index = (log_abundance_hat)) %>%
#   ggplot(aes(
#     year,
#     index,
#     color = factor(targeted),
#     group = interaction(targeted, classcode)
#   )) +
#   geom_line()

prepped_synth_data <-
  Synth::dataprep(
    foo = synth_data,
    predictors = colnames(synth_data)[str_detect(colnames(synth_data),"mean")],
    predictors.op = "mean",
    dependent = "log_abundance_hat",
    unit.variable = "numeric_classcode",
    unit.names.variable = "classcode",
    time.variable = "year",
    treatment.identifier = "targeted",
    controls.identifier = unique(synth_data$classcode)[unique(synth_data$classcode) != "targeted"],
    time.predictors.prior = years[years <= 2003],
    time.optimize.ssr = years[years <= 2003],
    time.plot = years
  )


synth_fit <- Synth::synth(prepped_synth_data)

gaps <-
  rownames_to_column(
    prepped_synth_data$Y1plot - (prepped_synth_data$Y0plot %*% synth_fit$solution.w) %>%
      as.data.frame()
  ) %>%
  rename(gap = w.weight,
         year = rowname) %>%
  mutate(year = as.numeric(year)) %>%
  mutate(synthetic = as.numeric(prepped_synth_data$Y0plot %*% synth_fit$solution.w)) %>% 
  mutate(treatment = gap + synthetic)

# path.plot(synth.res = synth_fit,
#           dataprep.res = prepped_synth_data
# ) 

total_gap_plot <- gaps %>% 
  ggplot(aes(year, gap)) + 
  geom_hline(aes(yintercept = 0), linetype = 2) +
  geom_vline(aes(xintercept = 2003), color = "red")+
  geom_line() + 
    labs(x = "Year", y = "Standard deviations from synthetic control")


total_synth_plot <- gaps %>% 
  select(year, synthetic, treatment) %>% 
  gather(source, value, -year) %>% 
  group_by(source) %>% 
  # mutate(value = scale(value)) %>% 
  ggplot(aes(year, value, color = source, linetype = source)) + 
  geom_vline(aes(xintercept = 2003), color = "red")+
  geom_line() + 
    labs(x = "Year", y = "Standard deviations from synthetic control")

```

```{r  total-synth, fig.cap = "Difference in centered and scaled standardized targeted abundance and synthetic standardized targeted abundance"}
total_gap_plot
```

As an extension, we repeated this process, but now treating each targeted species individually as the treated group, and the non-targeted species as the non-targeted. This is intended to explore whether we see clearer signals for individual species than we do for the targeted class as a whole. 

Overall we see similarly unclear results as the aggregate targeted synthetic control (and our main results). The synthetic control was better constructed for some individual species, but not clearly for any one, and most species showed some evidence of the upward-then-downward trend seen throughout our results (Fig.S\@ref(fig:synth-classcode-fits)). 


```{r, include = FALSE}

synth_foo <-
  function(treated_classcode,
           synth_data,
           targeted_classcodes) {
    # treated_classcode <- targeted_classcodes[1]
    
    temp_synth_data <- synth_data %>%
      filter(classcode == treated_classcode |
               !(classcode %in% targeted_classcodes))
    
    prepped_synth_data <-
      Synth::dataprep(
        foo = temp_synth_data,
        predictors = colnames(temp_synth_data)[str_detect(colnames(temp_synth_data), "mean")],
        predictors.op = "mean",
        dependent = "log_abundance_hat",
        unit.variable = "numeric_classcode",
        unit.names.variable = "classcode",
        time.variable = "year",
        treatment.identifier = treated_classcode,
        controls.identifier = unique(temp_synth_data$classcode)[unique(temp_synth_data$classcode) != treated_classcode],
        time.predictors.prior = c(2000:2003),
        time.optimize.ssr = c(2000:2003),
        time.plot = years
      )
    
    
    synth_fit <- Synth::synth(prepped_synth_data)
    
    gaps <-
      rownames_to_column(
        prepped_synth_data$Y1plot - (prepped_synth_data$Y0plot %*% synth_fit$solution.w) %>%
          as.data.frame()
      ) %>%
      rename(gap = w.weight,
             year = rowname) %>%
      mutate(year = as.numeric(year)) %>%
      mutate(synthetic = as.numeric(prepped_synth_data$Y0plot %*% synth_fit$solution.w)) %>%
      mutate(treatment = gap + synthetic)
  }

nontargeted_index <- data_frame(abundance_hat = fit_report$abundance_hat,
                               classcode = rep(1:n_distinct(fitted_data$classcode), each = length(years))) %>%
  mutate(log_abundance_hat = log(abundance_hat)) %>%
  group_by(classcode) %>%
  mutate(year = 1999 + 1:length(abundance_hat)) %>%
  mutate(scaled_abundance_hat = (abundance_hat - mean(abundance_hat)) / sd(abundance_hat)) %>%
  ungroup() %>%
  rename(numeric_classcode = classcode) %>%
  left_join(life_history, by = "numeric_classcode" ) %>% 
  left_join(unique(abundance_data$data[[1]] %>% select(classcode, targeted)), by = "classcode") %>% 
  select(log_abundance_hat, year, classcode, targeted)


synth_covariates <- pisco_data %>% 
  select(classcode, contains("mean"),year, targeted) %>% 
  select(-mean_length) %>% 
  gather(variable, value, -classcode,-year,-targeted) %>% 
  group_by(classcode, variable, year) %>% 
  summarise(mean_value = mean(value, na.rm = TRUE)) %>% 
  spread(variable, mean_value)


synth_data <- nontargeted_index %>% 
  left_join(synth_covariates, by = c("classcode","year")) %>% 
    mutate(numeric_classcode = as.numeric(factor(classcode))) %>% 
  group_by(classcode) %>% 
  mutate(log_abundance_hat = scale(exp(log_abundance_hat))) %>% 
  ungroup() %>% 
  as.data.frame()

targeted_classcodes <- unique(synth_data$classcode[synth_data$targeted == 1])

synth_classcode_fits <-
  tibble(targeted_classcodes = targeted_classcodes) %>%
  mutate(
    synthetic_fit = map(
      targeted_classcodes,
      synth_foo,
      synth_data = synth_data,
      targeted_classcodes = targeted_classcodes
    )
  )


synth_classcode_fits <- synth_classcode_fits %>% 
  unnest()

synth_classcode_fits_plot <- 
synth_classcode_fits %>% 
  ggplot(aes(year, gap)) + 
  geom_hline(aes(yintercept = 0), linetype = 2) +
  geom_vline(aes(xintercept = 2003), color = "red")+
  geom_line() + 
  facet_wrap(~targeted_classcodes) + 
  labs(x = "Year", y = "Standard deviations from synthetic control")


```




```{r synth-classcode-fits, fig.cap="Synthetic control gaps for each targeted species"}
synth_classcode_fits_plot + 
  theme_minimal()
```


## Testing Model Assumptions


### Simulation testing

We state that a difference-in-difference model using targeted and non-targeted species is capable (conditional on assumptions) of estimating the causal effect of MPAs. We simulated MPA outcomes to test this claim. We first test our estimation strategy under idealized circumstances, where recruitment is deterministic and PISCO divers all have constant and perfect observer skills. We simulate five species that vary only in their maximum size and length at maturity. For each of these species, we set one version that is targeted by fishing and one that is not. We set a constant fishing mortality rate for each simulated targeted species, and then ran two matched simulations, one with MPAs and one without. We then have our simulated divers sample data from each of these scenarios, and then pass the sampled biomass densities to a simplified version of our difference-in-difference model (omitting the probability of detection step). We can then compare the difference-in-difference estimates of the MPA effect to the true simulated effect. The difference in difference model is able to capture the simulated MPA effect under these circumstances (Fig.S\@ref(fig:simple-did-test))


```{r simple-did-test, fig.cap = "Simulated mean (red dashed line) and individual species (solid lines) MPA effects over time, along with difference-in-difference estimated MPA effects (mean with 95% confidence intervals)"}

load(file = file.path(run_dir,'simulated_did.Rdata'))

simple_performance$mixed_effect_did + 
  labs(title = '', x = "Years with MPA protection",
       y = "MPA Effect")
```


We then simulated a more complex example. We use the actual targeted and non-targeted species from our model. We assign species predominately seen in the western Channel Islands as "cold water" and those in the eastern Channel Islands as "warm water". We allow for stochasticity in recruitment. We use El Nio data as a simulated environmental recruitment driver, where we assume that El Nio events produce negative recruitment shocks for cold water species and *vice versa* for warm water species. We simulate three different divers each with different base skill levels, visual selectivities, and an evolving skill rate (such that observers get better over time). We hold fishing mortality rates constant for each species, although that fishing mortality affects each species differently because of intrinsic biological differences in maturity-at-age and steepness. We then test the ability of the difference-in-difference model to isolate the mean MPA effect across all of these targeted species, which our results show it is capable of doing (Fig.S\@ref(fig:complex-did-test)).

```{r complex-did-test,  fig.cap = "Simulated mean (red dashed line) and individual species (solid lines) MPA effects over time, along with difference-in-difference estimated MPA effects (mean with 95% confidence intervals)"}

pisco_performance$mixed_effect_did + 
    labs(title = '', x = "Years with MPA protection",
       y = "MPA Effect")

```

### Sensitivity to "missing" observations

Appropriately addressing the problem of "missing" observations is a critical challenge in any field observation study. If no observations of a given fish species were recorded on a given transect, should the density of that species on that transect be marked as zero, and influence the estimate of the overall mean density accordingly? The obvious answer seems to be yes, but what if that species simply does not live in the environment covered by a particular transect, or was not present during the particular time of the diver's observation? For our base runs, we assign a value of zero density on a given transect for any fish species that has been observed at least once at a given site at any time in our data but was not observed on that particular transect. If that species was never observed at that site, we do not include a zero for that species. Our rationale for this is that given the shifting nature of the sampled sites, and the intensity of sampling at those sites, we do not want to skew density trends by changes in the amount of suitable habitat for a given species sampled. However, this is clearly a strong assumption. For example, perhaps the decreasing trend in mean densities from 2000 to 2004 is due to increased number of sites (and therefore zeros) included in the data. To assess the potential importance of this choice, we can compare the mean densities of targeted and non-targeted species over time with the added zeros to the mean densities using only positive observations (i.e. not including any zeros in the data, (Fig.S\@ref(fig:nozero-raw-trend)). The trends in the raw densities, and most importantly the mean trends of targeted and non-targeted fishes, are nearly identical whether or not zeros are added, providing strong evidence that our choice of how to incorporate missing observations into the data are not strongly influencing our overall results. 

```{r nozero-raw-trend, fig.cap = "Centered and scaled mean annual density, excluding zeros, of included fishes (points) and smoothed means of targeted and non-targeted groups (line) over time" }

nozero_trend_plot <- base_run$data[[1]] %>% 
  filter(any_seen == T) %>% 
  select(year, targeted,classcode, log_density, any_seen) %>% 
  mutate(density = exp(log_density) * any_seen) %>% 
  group_by(classcode,targeted, year) %>% 
  summarise(md = mean(density)) %>% 
  group_by(classcode,targeted) %>% 
  mutate(smd = (md - mean(md)) / sd(md)) %>% 
  ggplot(aes(year, smd, color = targeted == 1, fill = targeted == 1)) + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line(aes(group = interaction(targeted, classcode)), alpha = 0.25) +
  geom_smooth() +
  scale_color_d3(name = "Targeted?") + 
  scale_fill_d3(name = "Targeted?") +
  labs(y = "Centered and Scaled Mean Density", x = "Year")


nozero_trend_plot
```

### Testing SUTVA with Convergent Cross Mapping

The difference-in-difference model also assumes that the targeted and non-targeted fishes do not directly or indirectly affect each other.This assumption is clearly violated on some level: all the fishes in this analysis are part of the same ecosystem and therefore interact to some degree. For example, if the protection of targeted predatory fishes results in increased mortality of non-targeted fishes, the model would attribute that as an increased regional effect (greater divergence between the abundance of targeted and non-targeted species). Given the time scale of analysis (15 years of protection), we do not feel that massive trophic cascades are likely to have developed yet, given both the pace and complexity of trophic cascade development [@babcock2010; @pershing2015a]. A complete assessment of evidence for trophic cascades in the Channel Islands is beyond the scope of this study, but to address this question somewhat we utilized convergent cross mapping *sensu* @sugihara2012 to test for a significant causal signal between different broad trophic groups in the data, implemented in the `rEDM` package in R. 

Convergent cross mapping is a nonlinear forecasting method that uses observed time series data to test for significant causal links between variables. Following methods laid out in @clark2015 and @sugihara2012, we pool the abundance of each broad trophic group by region (Fig.S\@ref(fig:trophic-plot). This uses the data from the islands as "replicates", requiring the assumption that the islands are all part of the same dynamic system, but allowing us to take advantage of the extra information provided by each island to further resolve the reconstructed manifolds. Using these aggregations, we then test whether the variables can be properly embedded, i.e., if they have predictable manifold dynamics. We do this through a simplex forecasting test, using an individual timeseries' own lags to build a manifold. For each timeseries, the "best embedding dimension" is an approximation of the dimensionality of the dynamic system, in other words, the number of dimensions that define and predict the evolving states of the timeseries. This analysis shows that only the carnivore, piscivore, and planktivores groups show evidence of significant predictability (that is, that past dynamics of these species groups can predict future dynamics, Fig.S\@ref(fig:embed-plot)). 

```{r trophic-plot, fig.cap="Centered and scaled densities by broad trophic group and island over time"}

trophic_groups <- cip_data %>% 
  select(classcode, broadtrophic) %>% 
  unique()


# dat <- abundance_trends %>%
#   left_join(trophic_groups, by = "classcode") %>%
#   group_by(broadtrophic, year) %>%
#   summarise(density = mean(scaled_abundance_hat)) %>%
#   group_by(broadtrophic) %>%
#   mutate(density = scale(density)) %>%
#   ungroup() %>% 
#   spread(broadtrophic, density) %>% 
#   arrange(year) %>% 
#   mutate(lag4_carnivore = lag(carnivore,4),
#          lag4_piscovore = lag(piscivore,4)) %>% 
#   na.omit() %>% 
#   ungroup() %>% 
#   filter(year > 1999) 
# dat %>%
#   ggplot(aes(year, density, color = broadtrophic)) +
#   geom_line()

dat <- cip_data %>%
  group_by(broadtrophic, region, site, side, transect, year, eventual_mpa) %>%
  summarise(density = sum(density_g_m2)) %>%
  group_by(broadtrophic, region, site, year) %>%
  summarise(mean_density = mean(density, na.rm = T)) %>%
  group_by(broadtrophic,region, year) %>%
  summarise(regional_density = mean(mean_density, na.rm = T)) %>% 
  ungroup() %>% 
  spread(broadtrophic, regional_density) %>% 
  group_by(region) %>% 
  arrange(year) %>% 
  mutate(lag4_carnivore = lag(carnivore,4),
         lag4_piscovore = lag(piscivore,4)) %>% 
  na.omit() %>% 
  ungroup() %>% 
  filter(year > 1999) 

 dat <- dat %>%
  select(-lag4_carnivore,-lag4_piscovore)%>%
  group_by(region)%>%
  mutate_at(vars(carnivore:planktivore),funs(norm=(.-mean(.))/sd(.)))->dat

group_trends_plot <- dat %>%
  select(region,year,contains("norm"))%>%
  gather("group","density",-region,-year)%>%
  ggplot(aes(year,density,col=group))+
  geom_line()+
  geom_point() +
  scale_color_locuszoom(name="Trophic Group",labels=c("carnivore","herbivore","piscivore","planktivore"))+
  labs(x="year",y="Centered and Scaled Density")+
  facet_wrap(~region)

group_trends_plot
```



```{r embed-plot, fig.cap = "Predictive skill as a function of embedding dimensions"}

## split data by region to analyze timeseries from each island separately
ana.dat <- dat %>% filter(region=="ANA")
sci.dat <- dat %>% filter(region=="SCI")
smi.dat <- dat %>% filter(region=="SMI")
sri.dat <- dat %>% filter(region=="SRI")

datnest <- dat %>% group_by(region) %>% nest()

datnorm <- dat %>% select(region,year,contains('norm')) %>% ungroup()

# have to record the segments corresponding to each "replicate" so simplex algorithm does not try to make predictions crossing time barriers
segs <- datnorm %>% mutate(ind=row_number()) %>% group_by(region) %>% summarise(first=first(ind),last=last(ind)) %>%
  select(-region)

var_names <- c("carnivore_norm","herbivore_norm","piscivore_norm","planktivore_norm")


regions.combined.simp.list <- map(var_names,function(x){
  temp <- datnorm %>% ungroup() %>% select(matches(x)) %>% as.data.frame()
  out <- simplex(as.numeric(temp[,1]),E=1:10,lib=as.matrix(segs),silent=T) %>%
    mutate(trophic=str_replace(x,"_norm",""))
  out
})


embed_plot <- bind_rows(regions.combined.simp.list) %>%
  ggplot(aes(E,rho,color=trophic))+
  geom_line(size=2)+
  facet_wrap(~trophic,nrow=2,scales="free_y")+
  geom_hline(yintercept = 0,color="black")+
  labs(x="Embedding Dimension (E)",y=expression(paste("Predictive Skill, ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  scale_color_locuszoom()+
  guides(color=F)

embed_plot

```

Focusing on just these three groups then (removing herbivores), we can test for causal relationships between groups using convergent cross mapping and the logic of Takens' theorem of dynamic systems. Generalizations of Takens' theorem indicate that if two variables (in our case, species or physical variables) are part of the same dynamic system, their individual dynamics should reflect their relative causal influence [@sugihara2012]. In other words, if one variable is causally forced by another, that forcing should leave a signature on the first time series. Convergent cross mapping (CCM) tests for causation by using the attractor/manifold built from the time series of one variable to predict another (hence the "cross-mapping"). In simple terms, the *causal effect of A on B is determined by how well B cross-maps A*.

There are two criteria for CCM to establish causality:  First, and most obviously, predictive cross-map skill using all available data should be significantly greater than zero. Second, that predictability should be convergent.  Convergence means that cross-mapped estimates improve with library length (the number of state-space vectors used to build the attractor), because the attractor is more fully resolved and therefore estimation error should decline. Convergence is key to distinguishing causation from simple or spurious correlation. If two variables are spuriously correlated and not causally linked, CCM should fail to satisfy this second criterion. Based on these criteria, there is little evidence of significant dynamic interactions between trophic groups (Fig.S\@ref(fig:cross-map-cp)-\@ref(fig:cross-map-pis)). Cross-mapping produced positive predictive skill, but was non-convergent for all cross-mappings with the exception of carnivores cross-mapping planktivores (providing some evidence that planktivore dynamics may be a driver of carnivore dynamics). This analysis provides evidence that trophic cascades are unlikely to be a significant driver of our results. It is important to note though that this analysis does not mean that trophic cascades could not emerge in this system, rather that we do not detect them with these data at this time. 

```{r cross-map-fxn}
# plots a cross mapping between two variables in the data, given their variable names (grp), their optimal embedding dimensions (from simplex forecasting), and their preferred names for plotting
xmap <- function(grp1,grp2,E1,E2,name1,name2){
    # cross-map group 1 to group 2
  
  ccm1 <- ccm(datnorm,lib=as.matrix(segs),pred=as.matrix(segs),E=E1,lib_column= grp1,target_column = grp2,lib_sizes = c(10,25,50,75),num_samples=100,replace=T,silent=T,RNGseed = 41389)
  
  # test for convergence (is predictability at max library size significantly greater than at minimum library size?)

  rhomeans1 <- ccm1 %>% ccm_means()
  
  conv_test1 <- t.test(ccm1$rho[ccm1$lib_size==10],ccm1$rho[ccm1$lib_size==75])$p.value
  if((rhomeans1$rho[rhomeans1$lib_size==75]-rhomeans1$rho[rhomeans1$lib_size==10])<0.05) conv_test1 <- 1
  conv_test1 <- ifelse(conv_test1<0.05,"Convergent","Non-convergent")
  
  xmap1 <- ccm1 %>%
    group_by(lib_size)%>%
    summarise(rhomean=mean(rho,na.rm=T),upper=quantile(rho, 0.975),lower=quantile(rho, 0.025))%>%
    ungroup()%>%
    ggplot(aes(lib_size,rhomean))+
    geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="red")+
    geom_line(color="darkorchid3")+
    geom_hline(aes(yintercept = 0), linetype = 2) +
    labs(x="Library Size",y=expression(paste(rho, " (predictive skill)")),title=paste0(name1," xmap ",name2,"\n","(",conv_test1,")"))+
    theme(plot.title = element_text(size=6))
  
  # cross map group 2 to group 1
  # inspect the output of simplex from the previous step and use the best embedding dimension (highest rho) for the carnivore time series
  
  ccm2 <- ccm(datnorm,lib=as.matrix(segs),pred=as.matrix(segs),E=E2,lib_column= grp2,target_column = grp1,lib_sizes = c(10,25,50,75),num_samples=100,replace=T,silent=T,RNGseed = 41389)
  
  rhomeans2 <- ccm2 %>% ccm_means()
  
  conv_test2 <- t.test(ccm2$rho[ccm2$lib_size==10],ccm2$rho[ccm2$lib_size==75])$p.value
  if((rhomeans2$rho[rhomeans2$lib_size==75]-rhomeans2$rho[rhomeans2$lib_size==10])<0.05) conv_test2 <- 1
  conv_test2 <- ifelse(conv_test2<0.05,"Convergent","Non-convergent")
  
  xmap2 <- ccm2 %>%
    group_by(lib_size)%>%
    summarise(rhomean=mean(rho,na.rm=T),upper=quantile(rho, 0.975),lower=quantile(rho, 0.025))%>%
    ungroup()%>%
    ggplot(aes(lib_size,rhomean))+
    geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="red")+
    geom_line(color="darkorchid3")+
    geom_hline(aes(yintercept = 0), linetype = 2) +
    labs(x="Library Size",y=expression(paste(rho, " (predictive skill)")),title=paste0(name2," xmap ",name1,"\n","(",conv_test2,")"))+
    theme(plot.title = element_text(size=6))
  
  cross_map_plot <- xmap1 + xmap2

cross_map_plot
}
```



```{r cross-map-cp, fig.cap = "Cross mapping of effect of piscivores on carnivores (A) and carnivores on piscivores (B) in the PISCO data from 2000 to 2017. Shaded region show 95% confidence interval"}

car_pis<-xmap(grp1="carnivore_norm",grp2="piscivore_norm",E1=4,E2=4,name1="Carnivores",name2="Piscivores")
car_pl <- xmap(grp1="carnivore_norm",grp2="planktivore_norm",E1=4,E2=4,name1="Carnivores",name2="Planktivores")
pl_pis <- xmap(grp1="planktivore_norm",grp2="piscivore_norm",E1=4,E2=4,name1="Planktivores",name2="Piscivores")

car_pis
```


```{r cross-map-pl, fig.cap = "Cross mapping of effect of planktivores on carnivores (A) and carnivores on planktivores (B) in the PISCO data from 2000 to 2017. Shaded region show 95% confidence interval"}

car_pl

```

```{r cross-map-pis, fig.cap = "Cross mapping of effect of piscivores on carnivores (A) and carnivores on planktivores (B) in the PISCO data from 2000 to 2017. Shaded region show 95% confidence interval"}

 pl_pis 
```


```{r trophic-cor-plot, fig.cap="Estimated correlation coefficients between broad trophic groups at the island by year resolution", eval = FALSE}

trophic_effects_plot <- cip_data %>%
  group_by(broadtrophic, region, site, side, transect, year, eventual_mpa) %>%
  summarise(density = sum(density_g_m2)) %>%
  group_by(broadtrophic, region, site, year) %>%
  summarise(mean_density = mean(density, na.rm = T)) %>%
  group_by(broadtrophic,region, year) %>%
  summarise(regional_density = mean(mean_density, na.rm = T)) %>% 
  ungroup() %>% 
  spread(broadtrophic, regional_density) %>% 
  group_by(region) %>% 
  arrange(year) %>% 
  mutate(lag4_carnivore = lag(carnivore,4),
         lag4_piscovore = lag(piscivore,4)) %>% 
  na.omit() %>% 
  ungroup() %>% 
  filter(year > 1999) %>% 
  select(-year,-region) %>% 
  corrr::correlate() %>% 
   gather("colname","correlation",-rowname) %>% 
  ggplot(aes(rowname, colname,fill = correlation)) + 
  geom_tile() + 
  geom_text(aes(rowname, colname, label = round(correlation,2))) + 
  scale_fill_gradient2(low = "tomato", mid = "white", high = "steelblue", midpoint = 0, limits = c(-1,1),
                       guide = guide_colorbar(frame.colour = "black",barheight = 13)) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1,
                                   hjust = 1),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) 

trophic_effects_plot

```


## Repeat Analysis with Kelp Forest Monitoring Data

As a robustness check to our main results, we repeated our analysis utilizing data provided by the [Kelp Forest Monitoring Program (KFM)](https://science.nature.nps.gov/im/units/medn/monitor/kelpforest.cfm) conducted in the Channel Islands. Despite having similar but different methods and survey locations, we find almost identical estimated trends in divergences between targeted and non-targeted species using the KFM data (Fig.S\@ref(fig:kfm-did)).

```{r kfm-did,fig.cap = "Estimated divergence in biomass densities of targeted and non-targeted fishes in the Channel Islands (i.e. integrated across inside and outside of MPAs) using the KFM data . MPAs are implemented in 2003 (red dashed line). Estimates are from a regression on log(abundance index), and so estimated effects roughly correspond to percentage changes"}

kfm_did_plot <- kfm_run$did_plot[[1]] + 
  scale_y_continuous(name = "Divergence from Non-Targeted", labels = percent) + 
  labs(caption = "")

kfm_did_plot

```

## MPA Only Analysis

Given trends in mean densities observed in the raw data, the "regional conservation effect" estimated by our model---defined as the divergence in trends between the targeted and non-targeted species across the Channel Islands region---is not surprising. By jumping through countless statistical hoops we reach a similar conclusion that we would just by looking at the divergences in the mean trends. The integration of data from inside and outside of MPAs is a possible explanation for this lack of a clear regional effect. If spillover is limited or has simply not developed yet, especially relative to the effect of fishing outside of MPAs, then it is possible that there is a clear positive effect inside the MPAs, a clear negative effect outside, and when we look across both types of sites we get an unclear average of the two. 

To address this, we can first repeat some exploratory data analysis of trends in densities inside and outside the MPAs for targeted and non-targeted species. @caselle2015 provides a thorough look at this question of differences inside and outside of MPAs. We update that analysis here to account for our specific questions of trend divergence, potential differences in filtering methods, to include data up through 2017, and to utilize our estimation method on just the inside-MPA data. For all exploratory analyses, we consider the same top `r length(top_species)` consistently observed species. Looking first at simple trends in total mean biomass density across these species inside and outside of MPAs, we find evidence that biomass densities inside the MPAs is increasing faster (and is higher inside) than outside (Fig.S\@ref(fig:bio-mpa)). 


```{r bio-mpa, fig.cap= "Annual mean aggregate biomass density (summed across all fishes) inside and outside of eventual MPA locations over time. Red dashed line indicates MPA implementation year"}

abundance_index_plot <- cip_data %>% 
  group_by(targeted, region,site,side, transect, year, eventual_mpa, classcode) %>% 
  summarise(density = sum(density_g_m2)) %>% 
  group_by(targeted,classcode, region,site, year, eventual_mpa) %>% 
  summarise(mean_density = mean(density, na.rm = T)) %>% 
  group_by(targeted, classcode, year, eventual_mpa) %>% 
  summarise(mmd = mean(mean_density, na.rm = T)) %>% 
  group_by(year, eventual_mpa) %>% 
  summarise(abundance_index = sum(mmd, na.rm = T)) %>% 
  ggplot(aes(year, abundance_index, color = eventual_mpa)) + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line(size = 2) + 
  scale_color_manual(values = c("#009ACD", "#548B54"), name = "" , labels = c("Non-MPA",'MPA')) + 
  scale_y_continuous(name = "Total Abundance Index")+
  labs(x="Year")

abundance_index_plot

```

Our proposed identification strategy here though is not that total biomass density should be different inside and outside, but that the non-targeted species should serve as the control to the targeted. If we believe that the MPA effects are greater inside the MPA, then we would expect to see stronger divergences in biomass densities between these two targeted and non-targeted fishes inside the MPAs than outside

```{r div-mpa, fig.cap="Trends in total biomass density inside and outside of eventual MPAs for targeted and non-targeted fishes. Red dashed line indicates MPA implementation year"}

facet_labels <- c(
  `TRUE` = "MPA",
  `FALSE` = "Non-MPA"
)

mpa_abundance_plot <- cip_data %>% 
  mutate(targeted = targeted == 1) %>% 
  group_by(targeted, region,site,side, transect, year, eventual_mpa, classcode) %>% 
  summarise(density = sum(density_g_m2)) %>% 
  group_by(targeted,classcode, region,site, year, eventual_mpa) %>% 
  summarise(mean_density = mean(density, na.rm = T)) %>% 
  group_by(targeted, classcode, year, eventual_mpa) %>% 
  summarise(mmd = mean(mean_density, na.rm = T)) %>% 
  group_by(year, targeted, eventual_mpa) %>% 
  summarise(abundance_index = sum(mmd, na.rm = T)) %>% 
  ungroup() %>% 
  group_by(targeted, eventual_mpa) %>% 
  mutate(abundance_index = (abundance_index - mean(abundance_index)) / sd(abundance_index)) %>% 
  ungroup() %>% 
  rename(`Eventual MPA?` = eventual_mpa) %>% 
  ggplot(aes(year, abundance_index, color = targeted)) + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line(size = 2) + 
  scale_color_manual(values = c("steelblue", "tomato") ,name = "",
                     labels = c("Non-Targeted","Targeted")) + 
  facet_wrap(~`Eventual MPA?`, labeller = labeller(`Eventual MPA?` = facet_labels)) + 
    scale_y_continuous(name = "Total Abundance Index")+
  labs(x='Year')

mpa_abundance_plot

```

Here we see a different picture. While there is some visual evidence that the targeted species were diverging from the non-targeted faster inside the MPAs than outside, both inside and outside we see that the trend in total biomass density of targeted species is trending downward, relative to the trend in the non-targeted species in recent years. This analysis is of total biomass density. However, our model estimates the mean difference in targeted and non-targeted species. Both have their advantages, but we chose the mean to reflect a hypothesis that the MPAs would provide positive benefits across all targeted species. The total biomass density could be strongly affected by a sharp increase or decrease in one or two species, even if the mean trend is different. Examining the mean trends though, we see the same results (Fig.S\@ref(fig:mean-div-mpa)). 

```{r mean-div-mpa, fig.cap = "Trends in mean total biomass density inside and outside of eventual MPAs for targeted and non-targeted fishes. Red dashed line indicates MPA implementation year"}

targeted_mpa_plot <- cip_data %>% 
  mutate(targeted = targeted == 1) %>% 
  group_by(targeted, region,site,side, transect, year, eventual_mpa, classcode) %>% 
  summarise(density = sum(density_g_m2)) %>% 
  group_by(targeted,classcode, region,site, year, eventual_mpa) %>% 
  summarise(mean_density = mean(density, na.rm = T)) %>% 
  group_by(targeted, classcode, year, eventual_mpa) %>% 
  summarise(mmd = mean(mean_density, na.rm = T)) %>% 
  group_by(year, targeted, eventual_mpa) %>% 
  summarise(abundance_index = mean(mmd, na.rm = T)) %>% 
  ungroup() %>% 
    group_by(targeted, eventual_mpa) %>% 
  mutate(abundance_index = (abundance_index - mean(abundance_index)) / sd(abundance_index)) %>% 
  ungroup() %>% 
  rename(`Eventual MPA?` = eventual_mpa) %>% 
  ggplot(aes(year, abundance_index, color = targeted)) + 
  geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line(size = 2) + 
  scale_color_manual(values = c("steelblue", "tomato") ,name = "Targeted?") + 
  facet_wrap(~`Eventual MPA?`, labeller = label_both) + 
    scale_y_continuous(name = "Mean Abundance Index")+
  labs(x="Year")

targeted_mpa_plot
```


Lastly, we can examine both the mean and individual trend to check clear species-by-species outliers in the overall biomass density trends. This analysis shows noise, but overall the targeted and non-targeted species seem to be following similar trends within their respective groups 

```{r cs-trends, fig.cap = "Centered and scaled biomass density trends for each fish grouped by targeted and non targeted (pale lines) and fitted LOESS smoother (with 95% confidence intervals around mean) and mean by targeted and non-targeted groups, inside and outside od MPAs. Red dashed line indicates MPA implementation year"}

species_mpa_trend_plot <- cip_data %>% 
  group_by(year, classcode, eventual_mpa, targeted) %>% 
  summarise(mean_density = mean(density_g_m2, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(targeted = targeted == 1) %>% 
  group_by(classcode, eventual_mpa) %>% 
  mutate(cs_density = (mean_density - mean(mean_density)) / sd(mean_density)) %>% 
  ungroup() %>% 
    rename(`Eventual MPA?` = eventual_mpa) %>% 
  ggplot(aes(year, cs_density, color = targeted, fill = targeted)) + 
    geom_vline(aes(xintercept = 2003), linetype = 2, color = "red") +
  geom_line(aes(group = interaction(classcode, targeted)),alpha = 0.5) + 
  geom_smooth() +
    scale_color_manual(values = c("steelblue", "tomato") ,name = "", labels = c("Non-Targeted","Targeted")) +
      scale_fill_manual(values = c("steelblue", "tomato") ,name = "",labels = c("Non-Targeted","Targeted")) +

    facet_wrap(~`Eventual MPA?`, labeller = labeller(`Eventual MPA?` = facet_labels)) + 
    labs(y = "Centered and Scaled Mean Density", x = "Year")

species_mpa_trend_plot

```

These visual assessments suggest that similar to our results looking both inside and outside of MPAs, we would expect that our estimation model fitted only on data from inside eventual MPAs would reach similar conclusions as our results fitted to data from both inside and outside MPAs. To test this, we re-ran our analysis, but only using data from sites that are eventually placed inside MPAs. Our results reflect the same trends as displayed in the raw data and the statistical region-wide analysis, providing robust statistical support to the conclusions we would reach from visually examining the raw data (Fig.S \@ref(fig:mpa-did)). 

```{r mpa-did,fig.cap = "Estimated divergence in biomass densities of targeted and non-targeted fishes inside eventual Channel Islands MPAs. MPAs are implement in 2003 (red dashed line). Estimates are from a regression on log(abundance index), and so estimated effects roughly correspond to percentage changes" }

mpa_did_plot <- mpa_run$did_plot[[1]] + 
       labs(x = "Year", y = "Estimate of Regional Effect",
          caption = "")

mpa_did_plot

```


## References


